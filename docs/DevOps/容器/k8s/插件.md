# 插件

## API

k8s 为一些底层组件定义了 API 规范，如果一个插件实现了这些 API ，则可以替换默认组件。比如：
- 容器运行时接口（Container Runtime Interface ，CRI）：供 k8s 调用容器运行时，从而管理容器、镜像。
  - 大部分容器运行时并不兼容 CRI ，因此 k8s 还开发了一些 shim 模块，用于将各种容器运行时对接到 CRI 。
    - 后来改为通过 containerd 或 CRI-O 来调用底层的容器运行时。
  - CRI 使得 k8s 与容器运行时解耦，允许 k8s 同时使用多种容器运行时。
- 容器网络接口（Container Network Interface ，CNI）：供 k8s 管理容器的网络。
- 容器存储接口（Container Storage Interface ，CSI）：供 k8s 管理容器的存储层。
  - k8s 本身提供了 hostPath、ConfigMap 等类型的 volume 。而一些第三方的存储程序可通过 CSI 接口接入 k8s 集群，提供一些其它类型的 volume 。

常见插件：
- kube-dns ：为 k8s 集群提供 DNS 服务。
- Kube-router
- Flannel ：一个 CNI 插件，比较简单。
- Calico ：一个 CNI 插件，比较复杂，功能更多。
- Dashboard ：提供 Web UI 。
- Federation ：提供跨可用区的集群。
  - k8s 原本是部署在同一局域网内的主机上，如果部署在跨地域（Region）的不同主机上，则网络延迟会比较大。
- Fluentd-elasticsearch ：采集、管理 k8s 集群的日志。



## Helm

：一个包管理工具，用于在 k8s 中部署应用。相当于 yum 是 CentOS 系统的包管理工具。
- [官方文档](https://helm.sh/docs/)

### 原理

- 基本用法：
  1. 用户准备一个要部署到 k8s 中的应用（比如一个 Web 网站的前后端），将所有配置文件（比如 Deployment 配置、环境变量），打包成一个 .tgz 文件，称为 Chart 。
  2. 用 helm 命令读取 Chart 文件，渲染成 Release 应用包，然后部署到 k8s 中。
      - Chart 可以包含一些模板文件，采用 Golang Template 语法，需要渲染才能得到最终的配置文件。
- Helm v2.0 采用 C/S 架构。
  - 客户端名为 helm ，负责管理 Chart 。
  - 服务器名为 tiller ，会将客户端发来的 Chart 文件渲染成 release 文件，然后传给 k8s apiserver 进行部署。
- Helm v3.0 于 2019 年 11 月发布，与 Helm2 不兼容，移除了 Tiller ，成为了一个纯客户端工具。
- Helm 支持添加远程仓库。可以从仓库下载 Chart ，也可以将本机的 Chart 推送到仓库。

### 安装

- 下载二进制包：
  ```sh
  VERSION=3.10.3
  wget https://get.helm.sh/helm-v$VERSION-linux-amd64.tar.gz
  tar -xf helm-v$VERSION-linux-amd64.tar.gz
  install linux-amd64/helm /usr/bin/
  ```

### 命令

```sh
helm
    # 关于制作 Chart
    create <name>     # 创建一个新的 Chart 目录，会包含一些模板文件
    lint <chart>      # 检查一个 Chart 的语法是否正确
    package           # 将一个 Chart 目录打包成一个 .tgz 文件
    template [NAME] [CHART] # 将 Chart 渲染成 Release
        > release.yml                # 将渲染结果保存到一个文件中
        -x templates/configmap.yaml  # 只渲染指定模板文件

    # 关于仓库
    repo
        add [name] [url]  # 添加一个远程仓库
        remove [name]...  # 删除仓库
        update [name]...  # 获取仓库的最新信息。如果不指定 name ，则更新所有仓库
        list              # 列出所有仓库
    search repo <string>  # 在所有仓库中，搜索名称包含该字符串的 Chart 。搜索时会使用本机缓存的仓库信息，可能需要执行 helm repo update
    pull <chart>          # 下载 Chart 到本机。可以指定位于远程的 Chart 文件的 URL ，或位于仓库的 Chart 名称
    push <path> <repo>    # 指定位于本机的 Chart 文件的路径，上传到仓库

    # 关于部署 Chart
    install <name> <chart>    # 将一个 Chart 渲染成指定名称的 Release ，然后部署到 k8s 。可以指定位于本机的 Chart 文件的路径、位于远程的 Chart 文件的 URL ，或位于仓库的 Chart 名称
        --set key1=value1,... # 在渲染 Release 时，输入一些变量。可多次使用该选项
        -f vars.yml           # --values ，从 YAML 文件导入变量
        --create-namespace    # 如果 Chart 使用的 k8s 命名空间不存在，则自动创建
        --dry-run             # 模拟执行命令，但并不实际部署 Chart
        -g                    # --generate-name ，自动命名 Release 。此时可省略 install <name> <chart> 中的 name ，重复 install 时不会命名冲突
        --version <string>    # 如果 Chart 文件包含多个版本，则选用一个版本。默认会安装最新一个版本
        --wait                # 等待 Chart 部署完成，比如等 Pod 启动成功。默认不会等待
        --timeout 5m          # 当前命令执行的超时时间
    uninstall <release>...    # 卸载 k8s 中的 Release 。等价于 helm delete 命令
        --wait                # 等待所有相关的 k8s 资源被删除
    upgrade <release> <chart> # 升级一个 Relase
    list                      # 列出 k8s 中的 Release

    --debug         # 打印调试信息
    --kubeconfig ~/.kube/config
    -n default        # --namespace ，指定 k8s 命名空间
    -A                # --all-namespaces ，指定所有 k8s 命名空间
```
- 例：
  ```sh
  helm repo add bitnami https://charts.bitnami.com/bitnami
  helm search repo nginx
  helm install nginx bitnami/nginx -n test --wait
  ```
- 执行 helm 命令时，会读取一些环境变量作为配置参数。例如：
  ```sh
  KUBECONFIG="~/.kube/config"           # 表示到哪读取 kubeconfig 配置文件
  HELM_CACHE_HOME="~/.cache/helm"       # Helm 的缓存文件目录
  HELM_CONFIG_HOME="~/.config/helm"     # Helm 的配置文件目录
  HELM_DATA_HOME="~/.local/share/helm"  # Helm 的数据文件目录
  ```


### Chart

Chart 的目录结构：
```sh
app/
├── Chart.yaml          # 描述该 Chart 的信息
├── templates/          # 存放该应用的配置文件
│   ├── deployment.yaml
│   └── service.yaml
├── values.yaml         # 用于给 templates 中的变量赋值
├── requirements.yaml   # 描述当前 Chart 依赖的其它 Chart
├── charts/             # 存放当前 Chart 依赖的其它 Chart
├── .helmignore         # 描述打包 Chart 时要忽略的文件
├── LICENSE
└── README.md
```

Chart.yaml 的示例：
```yaml
apiVersion: v1
appVersion: "1.0"
description: A Helm chart for Kubernetes
name: redis
version: 0.1.0
```

values.yaml 的示例：
```yaml
image:
  repository: myharbor.com/test/redis
  tag: 5.0.6
```

在 deployment.yaml 中使用 values 的示例：
```yaml
template:
  spec:
      containers:
      - image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
      ...
```
