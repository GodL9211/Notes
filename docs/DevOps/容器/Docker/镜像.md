# 镜像

- 每个 Docker镜像有两种标识符：
  - `image ID` ：镜像的 SHA256 哈希值。
  - `image:tag` ：镜像名与标签的组合，由用户自定义。
    - 通常将 tag 用于表示镜像的版本号。
- 悬空镜像（dangling images）：一些只有 ID 的镜像，没有镜像名和标签，而是名为 `<none>:<none>` 。

## 查看

```sh
docker image
            ls                # 显示本机的镜像（默认不显示悬空镜像）。等价于 docker images 命令
                -a            # 显示所有的镜像
            rm <image>...     # 删除镜像（只能删除未被容器使用的）
            prune             # 删除所有悬空镜像
                -a            # 删除所有未被容器使用的镜像
            history <image>   # 显示该镜像的构建命令，按时间倒序排列，及其增加的 layer 大小
                --no-trunc
```

## 拉取

```sh
docker
      pull    <image>[:tag]         # 从镜像仓库拉取镜像，即下载镜像
          --platform <os/arch>      # 只拉取指定平台的镜像。默认会拉取匹配当前操作系统的所有镜像
      push    <image>[:tag]         # 推送镜像到镜像仓库
      search  <image>               # 在远程镜像仓库中搜索某个镜像

      tag <image> <image>:<tag>     # 给镜像加上名称和 tag ，可以多次添加
      login -u leo tencentyun.com   # 使用一个用户名登录一个镜像仓库（然后会提示输入密码）
```
- 省略镜像 tag 时，默认采用 latest 作为 tag 。
  - 制作镜像时，通常将 latest 标签指向最新一个版本，便于用户拉取。
  - 正式使用时，不应该拉取镜像的 latest 版本，否则在不同时间拉取的 latest 版本可能不同。
  - 例：
    ```sh
    docker build . -t nginx:1.20        # 构建镜像
    docker tag  nginx:1.20 nginx:latest # 添加 latest tag

    docker push nginx:1.20              # 推送镜像
    docker push nginx                   # 相当于 docker push nginx:latest

    docker pull nginx:1.20              # 拉取镜像
    docker pull nginx                   # 相当于 docker pull nginx:latest
    ```
- Docker 镜像可以存储在宿主机上，供 dockerd 使用。也可以存储到镜像仓库服务器。
  - 默认采用官方的镜像仓库 docker.io ，它还提供了 Web 页面 hub.docker.com 。也可以指定其它镜像仓库，比如用 harbor 自己部署的服务器。
  - 例：
    ```sh
    docker pull docker.io/nginx         # 默认的镜像仓库可省略，因此可简写为 docker pull nginx
    docker pull harbor.test.com/nginx   # 使用指定的镜像仓库
    ```
- 有的软件的镜像不支持跨平台运行，因此提供了针对不同平台的镜像。常见的几种平台（OS/architecture）：
  ```sh
  windows/amd64     # 常用于 Windows 主机
  linux/amd64       # 常用于 Linux 主机
  linux/arm64/v8    # 常用于 Apple M1 CPU
  ```

## 导出

- Docker 镜像在宿主机上存储为一些零散的文件，可以用以下命令导出：
  ```sh
  docker save -o images.tar <image>...        # 将镜像打包成 tar 格式
  docker save <image>... | gzip > images.tgz  # 打包并压缩

  docker load -i images.tar                   # 导入镜像
  ```
- 例：
  ```sh
  [root@Centos ~]# docker save -o nginx.tar nginx:latest
  [root@Centos ~]# ls -lh
  total 131M
  -rw-------. 1 root root 131M Mar 28 16:04 nginx.tar
  [root@Centos ~]# tar -tf nginx.tar
  28d499c51144128e64b6ffefa6c714bbfaf3e55772b080d1b0636f1971cb3203/           # 每个目录对应一层 layer 。目录名是此时导出文件的哈希值，并不等于 layer.tar 的哈希值
  28d499c51144128e64b6ffefa6c714bbfaf3e55772b080d1b0636f1971cb3203/VERSION    # 该 layer 的格式规范，目前为 1.0
  28d499c51144128e64b6ffefa6c714bbfaf3e55772b080d1b0636f1971cb3203/json       # 该 layer 的配置文件，记录了其 id、父级 layer 的 id、构建时的 container_config
  28d499c51144128e64b6ffefa6c714bbfaf3e55772b080d1b0636f1971cb3203/layer.tar  # 该 layer 包含的所有文件
  40aef34ac16b8c7eee6da1869452f5c9b9963ab583415d4999565738c719ded9/
  40aef34ac16b8c7eee6da1869452f5c9b9963ab583415d4999565738c719ded9/VERSION
  40aef34ac16b8c7eee6da1869452f5c9b9963ab583415d4999565738c719ded9/json
  40aef34ac16b8c7eee6da1869452f5c9b9963ab583415d4999565738c719ded9/layer.tar
  456351a127e9a9ce4cc79f7f6ad9f401d1714e514780f1603fa0b263119e329b/
  456351a127e9a9ce4cc79f7f6ad9f401d1714e514780f1603fa0b263119e329b/VERSION
  456351a127e9a9ce4cc79f7f6ad9f401d1714e514780f1603fa0b263119e329b/json
  456351a127e9a9ce4cc79f7f6ad9f401d1714e514780f1603fa0b263119e329b/layer.tar
  9000127bc2e7878a10491bb7a16a4b5874e4bdf6a01952d14211fad55defdd0a/
  9000127bc2e7878a10491bb7a16a4b5874e4bdf6a01952d14211fad55defdd0a/VERSION
  9000127bc2e7878a10491bb7a16a4b5874e4bdf6a01952d14211fad55defdd0a/json
  9000127bc2e7878a10491bb7a16a4b5874e4bdf6a01952d14211fad55defdd0a/layer.tar
  b526b761d738d1fba0774ea5af56ae1e664c812c6ce75743d74773cb3867bf7b/
  b526b761d738d1fba0774ea5af56ae1e664c812c6ce75743d74773cb3867bf7b/VERSION
  b526b761d738d1fba0774ea5af56ae1e664c812c6ce75743d74773cb3867bf7b/json
  b526b761d738d1fba0774ea5af56ae1e664c812c6ce75743d74773cb3867bf7b/layer.tar
  b8cf2cbeabb915843204ceb7ef0055fecadd55c2b0c58ac030e01fe75235885a.json       # 一个以镜像哈希值为名的 JSON 文件，记录该镜像的详细配置
  c0b073121bb2a6106dae6af85ade7274253f26626661e6e3cb20b0fa7fb59475/
  c0b073121bb2a6106dae6af85ade7274253f26626661e6e3cb20b0fa7fb59475/VERSION
  c0b073121bb2a6106dae6af85ade7274253f26626661e6e3cb20b0fa7fb59475/json
  c0b073121bb2a6106dae6af85ade7274253f26626661e6e3cb20b0fa7fb59475/layer.tar
  manifest.json                                                               # 镜像的结构简介，记录了镜像名、tag、JSON 配置文件的路径、各个 layer 的路径
  repositories
  ```
  - docker pull 命令会根据 manifest.json 文件拉取镜像的各个 layer 。如果本机已存在，则不必下载。
  - JSON 配置文件的内容示例：
    ```json
    {
      "architecture": "amd64",
      "config": {                   // 记录该镜像的配置，主要由 Dockerfile 决定
        "Hostname": "",
        "Domainname": "",
        "User": "",
        "AttachStdin": false,
        "AttachStdout": false,
        "AttachStderr": false,
        "ExposedPorts": {
          "80/tcp": {}
        },
        "Tty": false,
        "OpenStdin": false,
        "StdinOnce": false,
        "Env": ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "NGINX_VERSION=1.20.2", "NJS_VERSION=0.7.0", "PKG_RELEASE=1~bullseye"],
        "Cmd": ["nginx", "-g", "daemon off;"],
        "Image": "sha256:8e9a1b312fca0584850ce522438997f952010118d95f408add7eed34b8a2462d",
        "Volumes": null,
        "WorkingDir": "",
        "Entrypoint": ["/docker-entrypoint.sh"],
        "OnBuild": null,
        "Labels": {
          "maintainer": "NGINX Docker Maintainers \u003cdocker-maint@nginx.com\u003e"
        },
        "StopSignal": "SIGQUIT"
      },
      "container": "d9a5e6a8c2e78750b6e1cf3e1c62542d0d9bac5e5d714744a652974b20b3f987",    // 记录构建镜像时的最后一个中间容器
      "container_config": {
        "Hostname": "d9a5e6a8c2e7",
        ...
      },
      "history": [{       // 记录该镜像的构建命令，按时间顺序排列
        "created": "2021-11-17T02:20:41.91188934Z",
        "created_by": "/bin/sh -c #(nop) ADD file:a2405ebb9892d98be2eb585f6121864d12b3fd983ebf15e5f0b7486e106a79c6 in / "
      }, ...
      {
        "created": "2021-11-17T10:39:44.423437008Z",
        "created_by": "/bin/sh -c #(nop)  CMD [\"nginx\" \"-g\" \"daemon off;\"]",
        "empty_layer": true
      }],
      "os": "linux",
      "rootfs": {         // 记录组成该镜像的各个 layer 的哈希值。创建容器时需要按先后顺序载入这些 layer ，生成 RootFS 文件系统
        "type": "layers",
        "diff_ids": ["sha256:e1bbcf243d0e7387fbfe5116a485426f90d3ddeb0b1738dca4e3502b6743b325", "sha256:72e7342f59d8d99e69f1a39796e9023fee99f2b9c72bfe75cd7cc8c86b43c918", ...]
      }
    }
    ```

## 制作

制作 Docker 镜像主要有两种方法：
- 将一个容器提交为镜像：
  ```sh
  docker commit <container> <image>:<tag>
  ```
  - 每次 commit 时，会在原镜像外部加上一层新的 layer 。因此 commit 次数越多，镜像的体积越大。

- 编写 Dockerfile 文件，然后根据它构建镜像：
  ```sh
  docker build <dir_to_Dockerfile>
              -t <image:tag>              # --tag ，给构建出的镜像加上名称和标签
              --build-arg VERSION="1.0"   # 传入构建参数给 Dockerfile
              --target  <stage>           # 构建到某个阶段就停止
              --network <name>            # 设置中间容器使用的网络
              --no-cache                  # 构建时不使用缓存
              --force-rm                  # 即使构建失败，也强制删除中间容器
  ```
  - 执行 docker build 命令时，会将 Dockerfile 所在目录及其子目录的所有文件（包括隐藏文件）作为构建上下文（build context），拷贝发送给 dockerd ，从而允许用 COPY 或 ADD 命令拷贝文件到容器中。
    - 可以在 `.dockerignore` 文件中声明不想被发送的文件或目录。
