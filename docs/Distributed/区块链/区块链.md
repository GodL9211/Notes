# 区块链

：block chain ，一种分布式数据库技术。以区块为单位存储数据，区块们以哈希链的形式串联，因此防伪。
- 区块链起源于比特币，用于存储交易信息，实现了去中心化交易。
- 本文主要分析比特币协议中的区块链原理。

## 原理

### 区块结构

- 如下图，一条区块链由多个区块串联组成，后一个区块会记录前一个区块的哈希值，构成哈希链。
  ![](./block_chain.jpg)
  - 哈希运算时采用 SHA256 算法。
  - 存储字节流时采用小端序。
  - 每个区块采用递增的序号作为标识符，又称为区块高度（Height）。
  - 每个区块最多允许包含 1MB 的数据，超过则视作无效区块。

- 一个区块在结构上分为两部分：
  - header
    - 用于存储该区块的元数据。
  - body
    - 用于存储交易信息。
    - 每笔交易相当于 SQL 数据库的一个事务。

- block header 的长度固定为 80 bytes ，按顺序记录以下信息：
  - version
    - ：区块链协议的版本。
    - 4 bytes ，int32_t 。
  - previous block header hash
    - ：上一个区块的 header 的哈希值。用于确保它们不会被篡改。
    - 32 bytes ，char[32] 。
  - merkle root hash
    - ：当前区块 body 中所有交易信息的 Merkle Tree 的根哈希。用于确保它们不会被篡改。
    - 32 bytes ，char[32] 。
  - timestamp
    - ：矿工打包当前区块时的 Unix time 时间戳。必须大于前 11 个区块的平均时间戳、不大于当前实际时间 +2 小时。
    - 4 bytes ，uint32_t 。
  - nBits（target threshold）
    - ：nonce 的目标阈值。
    - 4 bytes ，uint32_t 。
  - nonce
    - ：一个随机数。
    - 4 bytes ，uint32_t 。

### 挖矿难度

- 矿工打包新区块时，需要尝试指定 nonce 值，比如穷举。如果使得当前 header 的哈希值小于等于 target threshold ，则有权打包该区块，被其他矿工承认。
  - SHA256 哈希值的长度为 32 bytes ，而 target threshold 以有损压缩形式存储为 nBits ，长度为 4 bytes 。
  - 例：根据 nBits 计算出 target threshold
    ```py
    >>> nBits  = int('0x170cfecf', 16)                              # 假设 nBits 的取值
    >>> target = 256**(int('0x17', 16) - 3) * int('0x0cfecf', 16)   # 将第一个字节作为 256 的幂，再乘以后三个字节
    >>> '0x' + "{:064x}".format(target)
    '0x0000000000000000000cfecf0000000000000000000000000000000000000000'
    ```
    - 可见 nBits 第一个字节的值越大，会使 taget 越大，开头连续的 0 越少，因此挖矿难度越小。
- difficulty 表示挖矿难度。
  - 计算公式如下：
    ```py
    diffculty = difficulty_1_target / target
    ```
    - 可见 difficulty 与 target 成反比，取值越小则挖矿难度越小，最小为 1 。
  - difficulty_1_target 表示区块链的初始难度，是一个常数：
    ```py
    >>> difficulty_1_target = 2**(256-32)-1
    >>> '0x' + "{:064x}".format(difficulty_1_target)
    '0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
    >>> difficulty_1_target / target
    21659675333681.926
    ```
  - 当 difficulty 为 1 时，target 达到允许的最大值 '0x1d00FFFF' 。因为有损压缩丢失了右侧的所有 '0xF' ，所以有的程序会将 difficulty_1_target 计算成偏小的值：
    ```py
    >>> _target = 256**(int('0x1d', 16) - 3) * int('0x00FFFF', 16)
    >>> '0x' + "{:064x}".format(_target)
    '0x00000000ffff0000000000000000000000000000000000000000000000000000'
    >>> _target / target
    21659344833264.848
    ```
    - 丢失右侧 '0xF' 的 difficulty_1_target 常用于快速估算难度，称为 bdiff（Bitcoin difficulty）。
    - 标准的 difficulty_1_target 常用于正式挖矿，称为 pdiff（Pool difficulty）。
  - 例：根据 nBits 估算出 difficulty
    ```py
    >>> nBits      = int('0x170cfecf', 16)
    >>> difficulty = 256**(29 - (nBits >> 24))*(65535.0 / ((float)(nBits & 0xFFFFFF)))
    >>> difficulty
    21659344833264.848
    ```
  - BTC 预计每隔 10 分钟生成一个新区块。为了维持这一速率，会每隔 2016 个区块调整一次挖矿难度，重新计算 nBits ：
    ```py
    expected_time  = 2016*10    # 理论上最近 2016 个区块应该消耗 2016*10 分钟即 2 周
    actual_time    = ...        # 实际上最近 2016 个区块消耗的时长
    new_difficulty = old_difficulty * ( actual_time / expected_time )
    new_nBits      = ...        # 根据 new_difficulty 算出 new_nBits
    ```
- 理论上，SHA256 哈希值有 2^256 种可能性，而 nonce 只有 2^32 种可能性，因此可能穷举 nonce 的所有值之后依然不满足 target threshold 。
  - 例如 2020 年发布的蚂蚁矿机 S19 ，额定算力为 95 THash/s ，遍历 nonce 所有值的耗时不超过 1 秒：
    ```py
    >>> (2**32) / (95*10**9)
    0.045
    ```
  - 当 nonce 被穷举完时，矿工通常会在 coinbase 交易中使用一个 4 bytes 的随机数，称为 extraNonce ，从而增加到 2^64 种可能性。
  - 例如 2020 年的比特币全网算力达到了 150 EHash/s = 150 * 10^3 PHash/s = 150 * 10^6 THash/s ，遍历 nonce + extraNonce 消耗的秒数为：
    ```py
    >>> round((2**64) / (150*10**15))
    123
    ```
    因此挖矿难度自动上调得很大，从而限制产生新区块的耗时依然为 10 分钟。矿工还需要用其它变量来增加可能性。

### 账户

- BTC 的交易，采用椭圆曲线数字签名算法 ECDSA 进行非对称加密，其中采用的椭圆曲线为 secp256k1 。
  - 用户可以生成一对私钥、公钥，相当于一个银行账户的密码、用户名。
    - 私钥需要保密，而公钥公开给其他人。
  - 用户可以编写一个消息，用私钥加密该消息，然后将密文公布出去。
    - 其他人根据公钥即可解密该消息。
  - 实际上，用户是在椭圆曲线上选择一个点，其值作为私钥，然后计算出相关联的两个点，其值组合作为公钥。
    - 用户选择私钥时应该尽量随机，避免与其他人相同。
    - 通过私钥可以计算出对应的公钥，但不能通过公钥反推出私钥。而且值域庞大，使得穷举几乎不可能。

- 用户可自由创建任意个账户，过程如下：
  1. 用户随机生成一个私钥（private key）。
      - 私钥的长度为 256 bits ，通常表示成 Base58Check 编码值。
  2. 根据 ECDSA 算法，计算出私钥对应的公钥（public key）。
      - 公钥的长度为 512 bits ，通常表示成 Base58Check 编码值。
      - BTC 客户端从 v0.6 开始，在私钥末尾添加一个字节 `0x01` ，使得生成的公钥长度压缩为 264 bits ，称为压缩格式，也是一般钱包采用的导入格式（Wallet Import Format，WIF）。
  3. 计算公钥的 SHA256 哈希值，再计算其结果的 RIPEMD-160 哈希值。
      - 该过程是为了将公钥表示成更短的哈希值。
  4. 将公钥哈希值（public key hash）经过 Base58Check 编码，得到一个 34 位长度的十六进制数，公开给别人查看，称为账户地址（address）。

- Base58Check 编码是为了将数据表示成更短的值，并加上校验码，并不会加密原数据。过程如下：
  1. 输入原数据 payload 。
  2. 在 payload 之前加上 1 字节的地址版本号 version 。
      - P2PKH 地址的 version 为 0x00 ，因此 base58 编码之后，开头为 1 。
      - P2SH 地址的 version 为 0x05 ，因此编码之后，开头为 3 。
      - BTC 私钥的 version 为 0x80 ，因此编码之后，未压缩格式的开头为 5 ，压缩格式的开头为 K 或 L 。
  3. 对 version-payload 计算两次哈希值，取开头的 4 字节作为校验码 checksum 。
      - 如果网络传输之后，再次计算两次哈希值，发现开头与校验码不一致，则说明编码值出错。
  4. 在 payload 末尾加上校验码 checksum ，将 version-payload-checksum 进行 base58 编码。
      - 与 base64 相比，base58 的特点：
        - 移除了 `+/` 两个特殊字符，只允许使用大小写字母、数字。
        - 移除了 `0OIi` 四个容易混淆的字母。

### 交易

- block body 中可以包含 n≥1 笔交易（transaction），最大数量取决于区块的容量限制。
  - 包含的第一笔交易必须是 coinbase 交易。
    - coinbase 交易不存在输入，凭空产生一定量可以输出的 BTC ，作为打包该区块的矿工的奖励。
  - 其后可以包含 m≥0 笔普通交易。
    - 当交易被保存到区块中之后，其内容就不能被改变。
    - 通常采用交易的哈希值作为其标识符，称为 txid 。
    - BTC 交易时，最小的单位为聪（satoshis）。1 BTC = 10^8 聪。

- 一个交易主要包含以下内容：
  - version ：交易格式的版本号，占 4 bytes 。
  - in-counter ：表示输入项的数量。
  - inputs ：包含 n≥1 个输入项。
    - 每个输入项的主要内容：
      - index ：输入项在 inputs 中的序号，从 0 开始递增。
      - previous txid ：指向输入的 BTC 来自的之前交易。这会将该交易的 UTXO 全部输入当前交易。
      - sigScript
  - out-counter ：表示输出项的数量。
  - outputs ：包含 n≥1 个输出项。
    - 每个输出项的主要内容：
      - index
      - value ：输出的 BTC 数量。
      - pkScript
    - 一个交易的总输入减去总输出的差值，会被矿工作为手续费，即 `fee = sum(inputs) – sum(outputs)` 。
  - locktime ：表示允许将该交易打包到区块中的最早时间，占 4 bytes 。
    - 如果取值小于 5 亿，则视作区块高度。
    - 如果取值大于 5 亿，则视作 Unix 时间戳。
    - 交易通常将 locktime 设置为 0x00000000 ，不限制。

- 如果一个账户收到了一些 BTC ，则可以发起一笔交易，输入一些 BTC ，然后输出给其它账户。
  - 所有账户收到的 BTC ，都来自历史交易的输出，且源头都是 coinbase 交易。
  - 如果一个交易输出的 BTC ，尚未被目标账户花费，则称为未花费交易输出（Unspent TX Output，UTXO）。
    - 一个账户拥有的所有 UTXO ，称为该账户的余额。
    - 一个交易的 UTXO 必须被一次性全部花费。例如 UTXO 为 5 BTC 时，用户可以新建一个交易，转账 1 BTC 给别人，然后将剩下的 BTC 转账给自己。
  - 统计 BTC 区块链上发生的所有交易的输入、输出，就可以知道所有账户的余额。
    - BTC 并没有提供直接查询账户余额的数据库，但一些区块链浏览器提供了这种查询功能。

- 发起一个交易的过程如下：
  1. 用户编写一个交易。
  2. 用户生成交易的 sigScript ，存放在交易的 inputs 中。
  3. 用户将交易广播到 BTC 网络上，等待矿工将它打包入新区块。

#### sigScript

：签名脚本（Signature Script，sigScript）。
- sigScript 包含以下内容：
  - pubKey ：账户公钥
  - sig ：根据账户私钥，对交易数据生成 secp256k1 数字签名。
    - 其他人可以根据公钥，证明交易数据没有被篡改、该数字签名是由对应的私钥生成的。
- 交易延展性（Transaction Malleability）攻击
  - ：一种攻击方式，指改变未打包交易中的签名，使得交易的哈希值改变，导致引用该交易 txid 的其它交易失效。
  - 由于椭圆曲线的对称性，可以计算出两个有效的签名，还可以根据任意一个签名推算出另一个签名。
  - 常见的解决办法：
    - 规定用户只采用取值较小的那个签名。
    - 使用 SegWit 。

#### pkScript

：公钥脚本（Pubkey Script，pkScript），采用一种基于堆栈的脚本语言，包含一些指令。
- pkScript 可以声明一些条件，当 sigScript 满足条件时才能花费 UTXO 。
  - 比如 P2PKH 通常的条件是：输出 n 个 BTC ，并指定一个公钥。只有拥有该公钥对应私钥的人，才有权花费该 UTXO 。
- pkScript 又称为锁定脚本（locking script），因为它输出的 BTC 一直不可用，直到有人提供满足条件的 sigScript 。

- pkScript 的几种类型：
  - Pay To Pubkey（P2PK）
    - ：将 BTC 转账给公钥。
  - Pay To Public Key Hash（P2PKH）
    - ：将 BTC 转账给公钥哈希。
    - P2PK 常用于 BTC 早期的交易，后来被 P2PKH 取代。主要原因：
      - P2PKH 使用公钥哈希，更短。
      - P2PKH 使用公钥哈希，隐藏了公钥，提供了额外的安全性。直到用户花费该账户时，才会提供公钥。
  - Pay To Script Hash（P2SH）
    - ：将 BTC 转账给脚本哈希。
      - 如果其他人提供的 sigScript 中，包含与 P2SH 哈希一致的脚本，称为赎回脚本（redeem script），则有权花费该 UTXO 。
    - 通过赎回脚本可实现复杂的功能，常用于多重签名（Multisig）、SegWit 兼容地址。
  - Pay to Witness Pubkey Hash（P2WPKH）
  - Pay to Witness Script Hash（P2WSH）
  - Pay To Multisig
  - Null Data（空数据）
    - ：用于在 pkScript 中添加任意字节的空数据。




https://developer.bitcoin.org/devguide/index.html




### 矿工

P2P 点对点网络，每个节点会将消息传播给其它节点

- 每个区块必须包含一个或多个交易。这些交易中的第一个必须是 coinbase 交易，即生成该区块的奖励。
- 各节点在验证区块时，遵循一些相同的共识规则。
- 节点可以提议更改共识规则。根据兼容性，分为两种情况：
  - 软分叉（Soft Fork）：新的共识规则向前兼容旧规则，因此未升级的旧节点依然可以与新节点工作在同一条区块链上，接受对方生成的新区块。
    - 根据 BIP9 提案，一个软分叉获得 95% 矿工的支持之后，才会激活成为共识规则。
  - 硬分叉（Hard Fork）：新的共识规则不向前兼容，因此新、旧节点会生成两条区块链。

矿工的工作流程：
1. 所有矿工共同记录一些交易信息，打包成一个区块
2. 开始穷举 nonce 值，直到有某个矿工满足挖矿难度。

### 白皮书

- 2008 年，中本聪发布了 [比特币白皮书](https://bitcoin.org/bitcoin.pdf) ，设计了比特币（Bitcoin）的最初架构：
  - 去中心化：属于点对点的交易系统。用户可以直接转账给其它用户，不需要经过第三方中介机构。
  - 基于区块链，记录发生过的转账交易，防止被篡改。
    - 工作量证明（Proof-of-Work）：各节点都有权开采新区块，需要进行 CPU 哈希运算。
    - 成功创建新区块的节点，可以获得一定量的比特币。
    - 如果同时存在多条区块链，则最长的那条拥有的工作量证明最多，被各节点接受。


- 与传统的银行转账相比，区块链的特点：
  - 不需要担心中介机构是否诚实可靠、是否批准交易，节约了中介处理的耗时。
  - 隐私（Privacy）：所有转账信息是公开可查的，容易溯源。但账户公钥是匿名的，不需绑定身份信息。

<!--
运行网络的步骤如下:
1)新事务被广播到所有节点。
2)每个节点将新的事务收集到一个块中。
3)每个节点都在为它的块寻找一个困难的工作量证明。
4)当一个节点找到一个工作量证明时，它将该块广播给所有节点。
5)只有当区块中的所有交易都是有效的且未被消费时，节点才接受区块。
节点通过创建下一个区块来表达对该区块的接受链，使用接受块的散列作为前一个散列。
= 节点总是认为最长的链是正确的，并将继续工作扩展它。
- 如果两个节点同时广播下一个块的不同版本，一些节点可以先接收其中一个或另一个。在这种情况下，他们会在收到的第一个文件上工作，
但是要保存另一个分支，以防它变长。当发现下一个校对工作和一个分支变得更长时，这种关系将被打破;在另一个节点上工作的节点分支将切换到较长的分支
- 新的事务广播不一定需要到达所有节点。
- 激励（Incentive）：如果一个贪婪的攻击者能够组装了比所有诚实节点更强大的CPU能力，他应该发现按规则玩（挖矿收益、转账费用）更有利可图，比篡改区块链的收益更大。
- 各节点可以只在磁盘中保存最近的一连串区块，删除较旧的区块。
-->

### 转账

转账流程：
- 用账户发出一笔转账，公布到网络上。
- 矿工验证这笔转账，是否有效。
- 矿工将这笔转账的信息写入区块链。


矿工们总是优先处理手续费最高的交易

比特币协议规定，申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。
- 上一笔交易的 Hash（你从哪里得到这些比特币）
- 本次交易双方的地址
- 支付方的公钥
- 支付方的私钥生成的数字签名

验证这笔交易是否属实，需要三步：
- 第一步，找到上一笔交易，确认支付方的比特币来源。
- 第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。
- 第三步，使用公钥去解开数字签名，保证私钥属实。


确认交易的真实性以后，交易数据必须写入区块链的区块，才算完成。




## 数字货币

### 历史

- 2008 年，中本聪（Satoshi Nakamoto）发布一个论文，
- 2017 年 8 月，BTC 发生硬分叉，产生一个新币 Bitcoin Cash（BCH）
  - 将区块的容量限制从 1MB 增加到 8MB 。
  - 硬分叉之后，拥有 BTC 的原账户依然在 BCH 中存在，并得到等量的 BCH 币。

https://en.bitcoin.it/wiki/Category:History


- 2017 年，BTC 引入了隔离见证（SegWit），属于软分叉升级。
  - 原理：将交易中的见证数据（称为 witness ，主要包含 sigScript ）移出，改为存放在区块的 witness 区域，也被 Merkle Tree 引用。
    - 这会减小交易的一大半体积，可以在区块中打包更多交易。
    - 此时的区块称为 SegWit 格式。基础容量限制依然为 1MB ，但允许附加 witness 数据，总体积限制为 4MB 。
    - 此时改变 sigScript 时，不会影响交易的哈希值，避免了 Transaction Malleability 攻击。此时交易的哈希值称为 wtxid 。
  - 使用 SegWit 时，账户地址有两种格式：
    - 原生地址（Native）：采用 Bech32 编码格式，开头为以 bc1 。
    - 兼容地址（Nested）：采用 P2SH 地址，开头为以 3 。
      - 传统地址（Legacy）不支持与 SegWit 原生地址转账。
      - SegWit 兼容地址支持与传统地址、SegWit 原生地址转账。
  - SegWit 还涉及到 BTC 社区的治理问题。
    - 2015 年，BTC 的使用量已经很大，交易的处理速度、延迟成为社区的主要议题。
    - 2016 年，Bitcoin Core 加入 SegWit 功能，但主要矿工一直不同意激活 SegWit ，想谋取更多利益，比如 SegWit2x 。
    - 2017 年，社区的一个开发者通过 BIP148 提案提出了 UASF 方案，才使得 SegWit 正式激活。
      - 用户激活软分叉（User Activated Soft Fork，UASF）：占经济多数的账户节点，强制矿工从指定时间开始采用一个软分叉，否则会拒绝该矿工打包的区块。
      - BTC 的共识规则原本由矿工投票决定，而 UASF 使得用户也拥有了控制权。
- 2017 年 5 月，一些公司和矿池签署了纽约共识（New York Agreement，NYA），提议 SegWit2x 。
  - 原理：激活 SegWit2x ，然后将区块的基础容量限制从 1MB 增加到 2MB ，这属于硬分叉升级。
  - 该提议与 BCH 的区块扩容类似，受到 Bitcoin Core 开发人员的反对，最终在 11 月放弃了该提议。

## ETH


- 20016 年，以太坊开始了 The DAO 项目，众筹了大量 ETH ，但是被黑客通过漏洞转走了 360 万个 ETH 。
  - 事发后，ETH 开发者的解决方案是，通过硬分叉将区块链回滚到事发之前的状态，从而回滚交易。
  - 一些社区用户反对该硬分叉，称它违反了区块链的不可篡改特性，因此继续使用原链，称为以太坊经典（ETC）。



## 相关概念

- [bitcoin.org](https://bitcoin.org/)

- 区块链浏览器（Explorer）
  - ：一种 Web 网站，用于查看、搜索 BTC、ETH 等数字货币的区块链信息，比如每个区块包含的所有交易、每笔交易的内容、每个地址的余额。
  - blockchain.com 、BTC.com 网站提供了多个主流币种的区块链浏览器。

- 钱包（wallet）
  - ：一种管理数字货币账户的软件，采用 PC 端软件、app 等形式。
  - 数字货币的账户在区块链中记录，任何人都可以自由创建。但普通人不懂如何编程与区块链交互，所以需要用到第三方开发的钱包软件。
  - 主要分类：
    - 冷钱包
      - ：使用时不需要联网，因此私钥不会泄露。
      - 支持离线交易：在离线电脑上发起一笔转账，生成签名，然后拷贝到另一个联网的电脑上，公布到区块链。
    - 热钱包
      - ：使用时需要联网，因此私钥可能泄露。
      - 用户需要担心账户私钥被热钱包恶意窃取，或因为漏洞被攻击。

- 常见矿池：
  - BTC.com ：原本由比特大陆公司经营。2021 年，500 彩票网收购该矿池及域名，并将公司改名为比特矿业。

- Layer2 ：
  https://m.8btc.com/article/6699616
  https://m.8btc.com/article/6701801
  https://m.8btc.com/article/6701437
  https://m.8btc.com/article/6709513


- 去中心化交易所
  - Uniswap
  - 1inch ：DEFI 聚合器，可以从其它 DEX 交易所选出滑点最小的用于交易。

