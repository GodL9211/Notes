# 构建

- 简单的 Java 项目可以用 javac 命令直接编译，复杂的 Java 项目则通常用 Ant、Maven、Gradle 等构建工具自动地编译、打包。
- 构建 Java 项目时，通常将编译生成的类文件、配置文件、资源文件等文件按 ZIP 格式打包，做成扩展名为 .jar 的压缩包。
  - jar 包一般用于存储可直接运行的 Java 程序，或者是 Java 的类库。
  - 构建 Java Web 项目时，通常打包成扩展名为 .war 的压缩包。
- Artifact ：泛指项目的构建产物，又称为工件、构建物、制品。
- 构件：泛指独立的功能模块，可以在项目中调用其接口。
  - 构件可以保存为源代码、可执行文件等形式。

## 编译

### 原理

- Java 代码需要先编译才能运行，其流程如下：
  1. 将 .java 源文件编译成字节码，存储在 .class 类文件中。
  2. 由 JVM 读取字节码，解释成当前操作系统的机器代码并执行。

- 类文件 ：扩展名为 .class ，用于存储 .java 源文件编译生成的字节码，因此又称为字节码文件。
- 字节码（Byte-code）：一种二进制代码，是介于编程语言代码与机器代码之间的中间代码。
- JDK ：Java 开发环境工具包（Java SE Development Kit），包含 JRE 以及开发、调试、监控工具。
- JRE ：Java 运行环境工具包 (Java Runtime Environment)，只提供了运行 Java 程序所需的 JVM 、类库，因此体积比 JDK 小。
- JVM ：Java 虚拟机（Java Virtual Machine），用于运行 Java 的类文件。
  - Java 语言在不同操作系统上分别实现了 JVM ，使得同一个类文件可以被不同平台的 JVM 运行，而不必考虑平台的底层差异，不必修改代码或重新编译。
  - C 代码编译是直接生成当前操作系统的机器代码，而 Java 代码编译是生成字节码，以便移植到不同机器平台的 JVM 上运行。

### 流程

基本的编译流程如下：
1. 安装 JDK
2. 编写一个源文件 Hello.java ：
    ```java
    public class Hello {
      public static void main(String[] args) {
          System.out.println("Hello world");
      }
    }
    ```
3. 用 javac 命令编译源文件，生成类文件：
    ```sh
    [root@Centos ~]# ls
    Hello.java
    [root@Centos ~]# javac Hello.java     # 这会编译生成一个类文件 Hello.class
    [root@Centos ~]# ls
    Hello.class  Hello.java
    ```
4. 用 java 命令运行类文件（实际上是交给 JVM 运行）：
    ```sh
    [root@Centos ~]# java Hello
    Hello world
    [root@Centos ~]# java Hello.class     # 运行类文件时不需要输入扩展名 .class ，否则会被当做类名的一部分
    Error: Could not find or load main class Hello.class
    ```

## JDK

### 安装

- 用包管理工具安装 JDK ：
  ```sh
  yum install java-1.8.0-openjdk-devel
  ```
  ```sh
  apt install openjdk-8-jdk
  ```

- 或者从[官网](https://www.oracle.com/java/technologies/javase-downloads.html)下载二进制版：
  ```sh
  wget http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz --header "Cookie: oraclelicense=accept-securebackup-cookie"
  tar -zxvf jdk-8u141-linux-x64.tar.gz -C /usr/local/

  # 配置环境变量，从而能定位 java 命令
  echo 'export JAVA_HOME=/usr/local/jdk1.8.0_141' >> /etc/profile
  echo 'export PATH=$PATH:$JAVA_HOME/bin' >> /etc/profile
  source /etc/profile
  ```

- 或者用 Docker 部署：
  ```sh
  docker run -it --rm openjdk:8-jdk java
  ```

### javac 命令

```sh
javac
      *.java                # 编译源文件
      -sourcepath <path>    # 查找源文件的路径
      -classpath <path>     # 用于查找类库的路径。该设置会覆盖环境变量 CLASSPATH
      -d .                  # 编译出的类文件的保存路径
      -encoding utf-8       # 源文件的编码格式
```

### java 命令

```sh
java
      <class name>                        # 运行类文件
      -jar xxx.jar                        # 运行 jar 包（在前台运行）
      -jar jenkins.war --httpPort=8080    # 运行 war 包

      -classpath <path>                   # 用于查找类库（通常保存为 jar 包）的路径。该设置会覆盖环境变量 CLASSPATH
      -cp <path>                          # 等价于 -classpath 选项
      -D  <property>=<value>              # 设置一个属性的值。可以多次使用该选项
          user.timezone=GMT+08            # 设置时区

      -Xms500m                            # 设置 JVM 堆内存的初始大小
      -Xmx2g                              # 设置 JVM 堆内存的最大大小
      -Xss128k                            # 设置每个线程的堆栈大小
      -XX:+HeapDumpOnOutOfMemoryError     # 当堆内存溢出时，生成堆的内存快照
      -XX:HeapDumpPath=./heapdump.hprof

      -version                            # 显示版本信息
      -verbose jar                        # 显示 jar 包的安装目录
```
- `path` 默认为当前目录。如果指定多个路径，在 Winodws 上用 ; 分隔，在 Linux 上用 : 分隔。

## Ant

：一个 Java 项目的构建工具，可以自动进行 Java 项目的编译、测试、打包。
- [官方文档](https://ant.apache.org/manual-1.9.x/index.html)
- Ant 最初是用于构建 Tomcat ，后来在 2000 年作为一个独立项目发布。
- 用法：
  1. 为 Java 项目创建一个 build.xml 文件，作为 Ant 的配置文件。
  2. 使用 ant 命令编译：
      ```sh
      ant [target]...
          -f build.xml
      ```

### 配置

build.xml 的内容示例：
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!-- 项目名、项目目录、默认执行的任务 -->
<project name="test" basedir="/opt/test" default="compile">

    <!-- 定义一些属性，属性名由用户自定义，可像变量一样使用 -->
    <property name="src.dir"     value="src"/>
    <property name="lib.dir"     value="lib"/>
    <property name="classes.dir" value="classes"/>  <!-- 编译出的类文件的保存路径 -->
    <property name="build.dir"   value="build"/>
    <property name="jre.dir"     value="/usr/local/jdk1.8.0_101/jre/lib"/>

    <!-- 配置一些路径 -->
    <path id="compile.dependencies">
        <fileset dir="${lib.dir}" includes="*.jar"/>
    </path>
    <path id="java.dependencies">
        <fileset dir="${jre.dir}" includes="*.jar"/>
    </path>

    <!-- 定义一个 target ，作为被 Ant 执行的任务 -->
    <target name="init">
        <delete dir="${classes.dir}"/>
        <delete dir="${build.dir}"/>
        <mkdir  dir="${classes.dir}"/>
        <mkdir  dir="${build.dir}"/>
    </target>

    <target name="compile" depends="init">
        <javac debug="true" includeantruntime="false" srcdir="${src.dir}" destdir="${classes.dir}" encoding="UTF-8">
            <!-- <compilerarg line="-XDignore.symbol.file"/> -->
            <classpath>
                <path refid="compile.dependencies"/>
                <path refid="java.dependencies"/>
            </classpath>
        </javac>
    </target>

    <target name="build_war" depends="compile">
        <war destfile="${build.dir}/${ant.project.name}.war" webxml="${build.dir}/WEB-INF/web.xml">
            <fileset dir="${build.dir}"/>
            <lib     dir="${build.dir}/WEB-INF/lib"/>
            <classes dir="${build.dir}/WEB-INF/classes"/>
        </war>
    </target>

</project>
```

## Maven

：一个 Java 项目的管理工具，既可以构建 Java 项目，还可以下载、制作、管理 jar 包等构建产物。
- [官方文档](https://maven.apache.org/)
- 读音为 `['meɪv(ə)n]`
- 于 2004 年发布，比 Ant 的功能更多。
- 基于 POM（Project Object Model ，项目对象模型）管理 Java 项目。
- 用法：
  1. 调整 Java 项目的目录结构，以符合 POM 的规范。
  2. 使用 mvn 命令编译。

### 安装

- 用包管理工具安装：
  ```sh
  yum install maven
  ```
- 或者下载二进制版：
  ```sh
  wget https://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz
  tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /usr/local/
  echo 'export MAVEN_HOME=/usr/local/apache-maven-3.6.3' >> /etc/profile    # 配置环境变量
  echo 'export PATH=$PATH:$MAVEN_HOME/bin' >> /etc/profile
  source /etc/profile
  ```
- 或者用 Docker 部署：
  ```sh
  docker run -it --rm \
      -v maven-repo:/root/.m2 \   # 挂载本地仓库
      -v $PWD:/app \              # 挂载项目目录
      --workdir /app \
      maven:3.6-jdk-8 \
      mvn clean compile
  ```

### 命令

```sh
mvn
    compile         # 编译当前项目
    test            # 在 compile 的基础上，测试项目。这会先编译出测试用例的类文件，然后执行它们
    package         # 在 test    的基础上，打包项目。一般是生成 jar 包或 war 包
    install         # 在 package 的基础上，将构建产物安装到本地仓库
    deploy          # 在 install 的基础上，将构建产物上传到远程私服仓库

    clean           # 清理项目目录，比如删除 target 目录下的文件
    clean package   # 先执行 clean ，再执行另一个操作（也可以换成 install 等操作）

    -D  <property>=<value>    # 设置一个属性的值。可以多次使用该选项
        maven.test.skip=true  # 跳过 test 步骤
        file.encoding=UTF-8   # 设置编码格式
    -P  test,prod             # 激活一些配置文件（profiles），用逗号分隔

    -v              # 显示版本信息
    dependency:list # 列出项目的所有依赖
    dependency:tree # 以树形结构列出项目的所有依赖，可以看出它们之间的依赖关系
```
- 执行 `mvn deploy` 时，会依次执行多个步骤：resources、compile、testResources、testCompile、test、jar、install、deploy 。
  - 执行 `mvn package` 时，只是执行到 jar 打包步骤就停止。
  - 执行 `mvn clean deploy` 时，会先执行 clean 步骤。
- 例：创建一个 webapp 类型的项目
  ```sh
  mvn archetype:generate
      -DgroupId=com.example     # 组织名（网址倒序）
      -DartifactId=web_demo     # 项目名
      -DarchetypeArtifactId=maven-archetype-webapp  # 使用的项目模板
      -DinteractiveMode=false   # 是否进入交互模式
  ```
- 例：安装指定的 jar 包到本地仓库
  ```sh
  mvn install:install-file -Dfile=demo.jar -DgroupId=com.company -DartifactId=demo -Dversion=0.0.1 -Dpackaging=jar
  ```

### 目录结构

Maven 项目通常采用以下目录结构：
```sh
web_demo
├── pom.xml                     # 该项目的配置文件
├── src
│   ├── main                    # 存放源代码
│   │    ├── java               # 存放代码文件
│   │    ├── resources          # 存放资源文件
│   │    └── webapp
│   └── test                    # 存放测试代码
│       ├── java
│       └── resources
└── target                      # 存放 Maven 的编译产物
    ├── classes
    ├── maven-archiver
    │   └── pom.properties
    ├── web_demo                # 编译后的 webapp 目录，可以打包成 war 包
    │   ├── index.jsp
    │   ├── META-INF
    │   └── WEB-INF
    │       ├── classes
    │       └── web.xml
    └── web_demo.war            # war 包
```

### pom.xml

Maven 项目的配置文件 pom.xml 示例：
```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">

    <!-- pom.xml 的版本 -->
    <modelVersion>4.0.0</modelVersion>

    <!-- 该 Maven 项目的首要信息 -->
    <name>test_project</name>
    <description>The project is for test</description>
    <packaging>jar</packaging>      <!-- 打包方式，有 pom,jar, war, maven-plugin 等 -->
    <groupId>in.freewind</groupId>
    <artifactId>test_project</artifactId>
    <version>0.0.1</version>

    <!-- 设置一些属性的值，相当于全局变量，可以在 pom.xml 文件的其它位置用 ${propertie} 的方式调用 -->
    <properties>
        <!-- JDK 的版本 -->
        <java.version>1.8</java.version>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
        <!-- 编码格式 -->
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>

    <!-- 设置该项目使用的远程仓库 -->
    <distributionManagement>
      <repository>
        <id>aliyun_nexus</id>
        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
      </repository>
    </distributionManagement>

    <!-- 声明该项目依赖的 Artifact -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <version>1.1.5</version>
    </dependency>
    <dependency>
        <groupId>test</groupId>
        <artifactId>test</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </dependency>

</project>
```
- 每个 Artifact 用 `groupId:artifactId:version` 三种信息作为标识符。
  - groupId ：制作者的团体名称，一般用倒序的域名。
  - artifactId ：该 Artifact 的名称，在同一个 groupId 下唯一。
  - version ：该 Artifact 的版本。分为两种：
    - release ：正式版本，比如 `1.0.0` 。使用时，先尝试从本地仓库获取版本号相同的依赖，如果不存在，再从远程仓库下载到本地仓库，缓存起来。
    - SNAPSHOT ：快照版本，比如 `1.0.0-SNAPSHOT` 。使用时，先尝试从远程仓库获取版本号相同、修改时间更新的依赖，覆盖本地仓库的缓存。
- Maven 仓库用于存储 Artifact 的文件，分为两种：
  - 远程仓库
    - ：位于其它主机上的仓库，比如用 Nexus 搭建的私有仓库。
    - 在 pom.xml 中可以指定当前项目使用的远程仓库。
      - 如果没有指定远程仓库，或者指定的远程仓库不可用，则会默认使用 Maven 社区维护的中央仓库 `https://repo.maven.apache.org/maven2` 。
  - 本地仓库
    - ：位于本机某个目录下（默认为 `~/.m2/repository/`），用于缓存从远程仓库下载的依赖。

### settings.xml

执行 mvn 命令时，还会读取以下位置的配置文件：
```sh
~/.m2/settings.xml              # 当前用户的配置文件
$MAVEN_HOME/conf/settings.xml   # 全局的配置文件
```

settings.xml 示例：
```xml
<?xml version="1.0" encoding="UTF-8"?>

<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">

  <!-- 配置远程仓库的服务器访问账号。如果没配置成功，下载依赖时就会报错：Could not transfer artifact: Not authorized -->
  <servers>
    <server>
        <id>aliyun_nexus</id>
        <username>test</username>
        <password>******</password>
    </server>
  </servers>

  <!-- 可以配置多个称为 mirror 的远程仓库。这会拦截发向某些远程仓库的请求，交给镜像仓库处理。不过如果镜像仓库不可访问，并不会再尝试访问原来的远程仓库 -->
  <mirrors>
    <mirror>
      <id>aliyun_nexus</id>
      <!-- 用该镜像仓库替换哪些远程仓库，比如 <mirrorOf>repo1,repo2</mirrorOf> -->
      <mirrorOf>*</mirrorOf>
      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
    </mirror>
  </mirrors>

</settings>
```
- 可以在 pom.xml 中声明项目使用的远程仓库，并在 settings.xml 中声明镜像仓库，替换远程仓库，从而更灵活地切换项目使用的远程仓库。

## Gradle

：一个 Java 项目的构建工具。
- [官方文档](https://gradle.org/guides/#getting-started)
- 于 2012 年发布。
- 基于 Groovy 语言编写构建脚本，因此比 Maven 更灵活。
