# 事务

：指用户对数据库的一次操作。
- 一个事务可能是一个简单的读操作、写操作，也可能包含多个命令。

## ACID

为了避免执行事务时出错，数据库应该实现事务的 ACID 四种特性。
- **原子性（Atomicity）**
  - ：一个事务是像原子一样的基本单元，不能拆分。要么完成，要么不完成，不存在其它状态。
  - 为了保证原子性，当一个事务执行失败时，数据库应该恢复到执行之前的原状态。
- **一致性（Consistency）**
  - ：当多个用户同时访问数据库时，读取到的数据是完全相同的。
  - 通过并发锁可以让并发事务变成串行事务，保证一致性，但会降低并发性能。
  - 数据库本身可以阻止用户查看尚未同步的数据，从而保证一致性。
- **隔离性（Isolation）**
  - ：各个事务之间相互隔离。当一个事务执行失败时，不会影响到其它事务。
  - 隔离一个执行失败的事务有两种策略：乐观、悲观。
- **持久性（Durability）**
  - ：一个成功完成的事务会对数据库造成持久的影响（主要是指写入的数据不会丢失），只可能被后续事务的影响覆盖。

## 并发事务

### 常见问题

多个事务同时操作同一个数据时，可能引发以下问题：
- 丢失更新（Lost Update）
  - ：多个事务同时修改数据时，后提交的事务覆盖了先提交的事务的修改。
  - 第一类情况：事务A读取到数据的值为 10 ，加一之后提交为 11 。同时事务B也读取到该数据的值为 10 ，经过任意修改之后又回滚为 10 ，并且在事务A之后提交，使得该数据最终保存为 10 。
  - 第二类情况：事务A读取到数据的值为 10 ，加一之后提交为 11 。同时事务B也读取到该数据的值为 10 ，减一之后提交为 9 ，并且在事务A之后提交，使得该数据最终保存为 9 。
- 脏读（Dirty Read）
  - ：当事务A修改了数据但尚未提交时，其它事务可能读取到被修改之后的该数据。如果事务A放弃提交，则其它事务读到的数据就是错的。
- 不可重复读（Unrepeatable Read）
  - ：如果事务B对数据进行了两次读操作，而在这两次读操作期间该数据被修改了，就会导致事务B两次读取到的数据不同。
- 幻读（Phantom Read）
  - ：如果事务B对数据进行了两次读操作，而在这两次读操作期间，其它事务在该范围内新增了数据行，就会导致事务B第二次读取到突然出现的新数据。

### 数据库锁

为了避免并发事务产生冲突，事务可以在操作之前对数据加锁，限制其它事务对该数据的操作，等操作完成之后再释放锁。
- 使用场景：
  - 如果当前事务是读取数据，其它事务也只是读取数据，则一般不需要加锁。
  - 如果当前事务是读取数据，其它事务可能修改数据，则应该加锁来保护当前事务。
  - 如果当前事务是修改数据，则应该加锁来保护其它事务。
- 如果数据库没有提供合适的锁机制，就需要用户自己编程实现，限制客户端的行为。

按严格程度分类：
- 共享锁（Share Locks）：又称为 S 锁、只读锁。
  - 允许所有事务读取该数据、加 S 锁，禁止所有事务修改该数据、加 X 锁。
- 排它锁（Exclusive Locks）：又称为 X 锁、写锁。
  - 允许当前事务读取、修改该数据，禁止其它事务读取、修改该数据、加锁。
  - 例如：事务A对数据加 X 锁之后，其它事务必须要等待事务A释放锁，才能操作该数据。

按使用策略分类：
- 悲观锁：每次读取、修改数据时都加锁。
  - 适用于经常修改数据的情况。
- 乐观锁：仅修改数据时加锁。
  - 适用于很少修改数据的情况。

按控制范围分类：
- 行级锁
- 表级锁

### 封锁协议

：指S锁、X锁的一些基本用法。
- 一级封锁协议：要求事务A在修改数据之前必须加X锁，直到事务结束才能释放锁。
  - 能防止“丢失更新”的问题。
- 二级封锁协议：在一级的基础上，要求事务A在读取数据之前必须加S锁，读取之后可以立即释放锁。
  - 能防止“丢失更新”、“脏读”的问题。
- 三级封锁协议：在二级的基础上，要求事务A在读取数据之前必须加S，直到事务结束才能释放锁。
  - 能防止“丢失更新”、“脏读”、“不可重复读”的问题。
- 两段锁协议：将事务的执行时期分为前后两个阶段，在前一个阶段只能加锁、不能释放锁，在后一个阶段只能释放锁、不能加锁。
  - 两段锁协议是实现“可串行化”隔离级别的充分条件。
  - MySQL 的 InnoDB 引擎就是采用两段锁协议，根据隔离级别自动加锁，并同时释放所有锁。

### 隔离级别

SQL标准定义了 4 种并发事务的隔离级别，从低到高排列如下：
- 读取未提交内容（Read Uncommitted）
  - ：当事务A修改了数据但尚未提交时，允许其它事务读取被修改之后的该数据。
  - 这种隔离级别最不安全，能防止“丢失更新”的问题，但存在“脏读”、“不可重复读”、“幻读”的问题。
- 读取已提交内容（Read Committed）
  - ：当事务A修改了数据且提交之后，才允许其它事务读取被修改之后的该数据，否则看到的是原数据。
  - 存在“不可重复读”、“幻读”的问题。
  - 这是大部分数据库的默认隔离级别。
- 可重复读（Repeatable Read）
  - ：保证一个事务在执行期间对同一数据的多次读取结果相同。
  - 存在“幻读”的问题。
  - 这是 MySQL 的默认隔离级别，并且 InnoDB 引擎通过多版本并发控制（Mutil-Version Concurrency Control，MVCC）解决了“幻读”的问题。
- 可串行化（Serializable）
  - ：当一个事务对数据进行写操作时，不允许其它事务对该数据进行读操作、写操作。（即加上排它锁）
  - 这种隔离级别最安全，但是事务的执行速度最慢。

### 活锁、死锁

使用数据库锁时可能产生活锁、死锁的问题。
- 活锁：事务A、B、C先后请求对数据加锁，数据库系统先把锁分配给事务A，然后却分配给事务C，导致事务B多等待了一段时间，甚至一直等待下去。
  - 解决方法：要求数据库系统按先来后到的原则分配锁。
- 死锁：事务A对数据m加锁之后，申请对数据n加锁，事务B对数据n加锁之后，申请对数据m加锁。这会导致两个事务都在等待获取对方数据的锁，一直僵持下去。
  - 解决方法：
    - 如果总共需要锁住的数据不多，可以让每个事务都一次性申请所有锁。
    - 如果总共需要申请的锁不多，可以让每个事务都按特定顺序申请锁。
    - 检查事务的执行时间，如果超时过久就可能是产生了死锁，需要人工排除。
