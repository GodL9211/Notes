# 主从+哨兵集群

Redis常见的集群方案：
- 主从+哨兵集群：类似Mysql的主从架构，加上哨兵自动进行主从切换，实现高可用。
- codis集群
  - 分成多个独立工作的小组，每组是一个小的主从架构。
  - 用一个proxy统一管理所有组。
- cluster集群：由Redis官方提出，

## 主从架构

：由一个Redis作为master，负责写操作；多个Redis作为slave，负责读操作并自动同步master的数据。
- 与MySQL的主从架构类似，部署简单，但能力有限，只适用于小型项目。
- 主从架构可以实现读写分离，但Redis工作在内存中，读写分离的作用不大。
- 为了政治正确，Redis逐渐将slave改名为replica。

### 部署

- 部署master时，像普通Redis一样配置即可。
- 部署slave时，先像普通Redis一样配置，再在配置文件中添加如下信息：
    ```conf
    replicaof 10.0.0.1 6379    # 设置master
    masterauth ******          # master的密码
    replica-read-only yes      # 如果该节点为slave，则只允许读操作
    ```
  - 用这样的配置文件启动slave之后，进入slave或master的终端，执行`info Replication`即可查看主从服务器的信息。如下：
    ```shell
    127.0.0.1:6379> info Replication
    # Replication
    role:slave
    master_host:redis-1
    master_port:6379
    master_link_status:up       # 表示已成功连接到master
    ```

## 哨兵

：一个特殊的Redis服务器，用于监控主从架构的Redis服务器，可以自动进行主从切换，实现Redis的高可用。
- 通常在多个主机上运行多个哨兵，构成分布式监控系统，实现哨兵的高可用。
- 哨兵默认监听26379端口，供Redis客户端连接。客户端可以连接到任一哨兵，通过哨兵连接到当前的master和slave。
- [官方文档](https://redis.io/topics/sentinel)

运行原理：
- 哨兵在运行时会自动重写自己的配置文件，在主从切换时还会通过config rewrite命令重写Redis的配置文件。
- 哨兵每隔10秒会向master发送info命令，发现各个Redis节点，作为known-replica、known-sentinel记录在自己的配置文件中。
  <br>已下线的Redis服务器、哨兵依然会记录在哨兵的配置文件中。
- 哨兵每隔2秒会在master的消息队列上发布消息，被其它哨兵订阅。这样哨兵之间可以相互发现、通信。（哨兵之间不会直接通信）
- 哨兵每隔1秒会向所有Redis服务器、其它哨兵发送ping命令，如果在一定时间内没收到响应就认为对方下线了。
- 如果一个哨兵认为master下线了（称为主观下线，sdown），就向其它哨兵广播这一信息。如果超过quorum数量的哨兵都认为master下线了（称为客观下线，odown），就开始救援。

救援过程（称为failover）：
- 哨兵们投票选出一个leader哨兵，一个哨兵需要获得超过半数的投票才能获选。
- leader哨兵选出一个合格的slave担任新的master，把旧master改为slave。
- leader哨兵通知其它Redis、哨兵，让它们连接到新的master。
- 如果救援过程失败，则重新开始救援。

### 部署

- 哨兵集群需要部署至少三个、奇数个哨兵服务器。如果启动的哨兵数过少，就可能达不到同意救援的哨兵数。
- 哨兵不必与Redis服务器运行在同一主机上，只需与各个Redis服务器的网络连通。
- 主从切换时，哨兵会自动配置 replicaof ，但不会自动配置Redis的密码，因此要在master、slave的配置文件中注明两份相同的密码：
    ```conf
    requirepass ******
    masterauth ******
    ```

执行`vim /etc/redis/sentinel.conf`编辑哨兵的配置文件，如下：
```conf
protected-mode no   # 相当于bind 0.0.0.0
port 26379
daemonize yes
dir /etc/redis/
logfile /var/log/redis-sentinel.log
pidfile /var/run/redis-sentinel.pid

sentinel monitor master1 10.0.0.1 6379 2      # 监控的master
sentinel auth-pass master1 ******             # master的密码
sentinel down-after-milliseconds master1 1000 # 哨兵不能连接到master超过多久时（单位ms），就判断master下线了
sentinel parallel-syncs master1 1             # 选出新master之后，同时安排多少个slave与它开始同步
sentinel failover-timeout master1 10000       # 救援过程的超时时间（单位ms），超过该时间之后就认为救援失败
sentinel deny-scripts-reconfig yes            # 不允许在Redis终端用SENTINEL SET进行配置
```
- 哨兵在启动时只会连接到master，因此只需配置当前master的ip和密码。
- 当哨兵切换master之后，新的master会使用原master的名字。
- sentinel monitor的最后一个字段称为quorum（法定人数），表示至少有多少个哨兵认为master下线了，就由其中一个哨兵开始救援。
- 执行`redis-server /etc/redis/sentinel.conf --sentinel`启动哨兵。

执行`redis-cli -p 26379`可进入哨兵的终端，常用的命令如下：
```shell
info                         # 显示该哨兵的信息
SENTINEL masters             # 显示所有master的信息
SENTINEL slaves <master>     # 显示指定master的所有slave的信息
SENTINEL sentinels <master>  # 显示指定master的所有哨兵的信息
SENTINEL failover <master>   # 强制开始一次救援，切换master
SENTINEL reset <master>      # 清空指定master及其slave、哨兵的配置文件，并自动按当前状态进行配置
```

## 例

部署一主二从集群，并在它们三个主机上分别部署哨兵。
终止master，可看到哨兵的日志如下：
```
202:X 18 Nov 2019 17:02:12.468 # +sdown master master1 10.244.79.33 6379                       # 当前哨兵检测到master下线
202:X 18 Nov 2019 17:02:12.583 # +new-epoch 12                                                 # 开始一次救援
202:X 18 Nov 2019 17:02:12.590 # +vote-for-leader 4f648158ea1a5f8df03b001396042d18cef56367 12  # 选举出leader哨兵
202:X 18 Nov 2019 17:02:13.547 # +odown master master1 10.244.79.33 6379 #quorum 3/2           # 有3个哨兵认为master下线，决定开始救援
202:X 18 Nov 2019 17:02:13.644 # +switch-master master1 10.244.79.33 6379 10.244.53.62 6379    # 将master从.33节点改为.62节点
202:X 18 Nov 2019 17:02:13.645 * +slave slave 10.244.25.157:6379 10.244.25.157 6379 @ master1 10.244.53.62 6379  # 让.157节点跟随新master
263:X 18 Nov 2019 17:02:16.355 * +slave slave 10.244.79.33:6379 10.244.79.33 6379 @ master1 10.244.53.62 6379    # 让.33节点跟随新master
```
如果failover失败，哨兵会重新开始救援，如下：
```
503:X 18 Nov 2019 15:55:18.755 # +new-epoch 21
503:X 18 Nov 2019 15:55:18.755 # +try-failover master master1 10.244.79.33 6379
503:X 18 Nov 2019 15:55:18.762 # +vote-for-leader 91ad63983edf9cfc378b2a37491c5621ebfceff5 21
503:X 18 Nov 2019 15:55:18.776 # dc54b5f06544c8bf830b9f8b00f199b96e0e6b16 voted for 91ad63983edf9cfc378b2a37491c5621ebfceff5 21
503:X 18 Nov 2019 15:55:18.778 # d2ceda111b29ad5f6e3932864fb2b7ca8e2309ff voted for 91ad63983edf9cfc378b2a37491c5621ebfceff5 21
503:X 18 Nov 2019 15:55:18.817 # +elected-leader master master1 10.244.79.33 6379
503:X 18 Nov 2019 15:55:18.818 # +failover-state-select-slave master master1 10.244.79.33 6379
503:X 18 Nov 2019 15:55:18.894 # -failover-abort-no-good-slave master master1 10.244.79.33 6379
503:X 18 Nov 2019 15:55:18.995 # Next failover delay: I will not start a failover before Mon Nov 18 15:55:39 2019
```
- 上方，failover-abort-no-good-slave表示没有找到合格的slave来担任master，原因可能是：
  - 哨兵不能连接到slave的ip或端口
  - slave监听的是127.0.0.1
  - 哨兵没有使用正确的密码登录slave
