# 管理单元

- MySQL 的管理单元主要分为：
  - 数据库（database）
    - 一个 MySQL 实例中可以创建多个数据库。
    - MySQL 中的 database 又称为 schema 。
  - 数据表（table）
    - 一个数据库中可以创建多个数据表，每个数据表需要定义至少一个列。
  - 数据行（row）
    - 一个数据表中可以插入多行数据。
- database、table 的名称区分大小写，而 column、index 的名称不区分大小写。
  - 这些标识符一般都采用小写，方便与 SQL 的大写关键字区分开来。
  - 如果在同一作用域创建同名的对象，则会报错：Duplicate name

## 数据库

```sql
show databases;             -- 显示所有数据库
show databases like 'xx%';  -- 筛选出指定名称的数据库

use <db>;                   -- 切换到指定的数据库（客户端同时只能切换到一个数据库）

create database <db>;       -- 创建一个数据库
drop database <db>;         -- 删除一个数据库
```
- MySQL 自带了四个数据库：
  - mysql ：用于存储用户表、权限表、当前引擎、事件、日志等重要信息。
  - information_schema ：用于存储元数据，比如所有存在的数据库、数据表、索引，所有可用的引擎、字符集、文件。
  - performance_schema ：用于存储数据库的运行状态、性能指标。
  - sys ：用途与 performance_schema 相似，但内容少一些。

## 数据表

### 查

```sql
show tables;            -- 显示当前数据库的所有数据表
show tables like 'xx%'; -- 筛选出指定名称的数据表

show table status;      -- 显示所有数据表的状态
show columns from <db>; -- 显示指定数据表中所有列的配置信息
desc <tb>;              -- 相当于 show columns from <tb>;
show create table tb1;  -- 查看创建某个表的完整 create 命令，便于拷贝或修改该表
```
- 切换到一个数据库之后，就可以直接操作其中的数据表。否则每次操作数据表时，都需要指明是哪个数据库。如下：
  ```sql
  show tables from <db>;
  desc <db>.<tb>;
  ```

### 增

例：
```sql
CREATE TABLE tb1(                                         -- 创建一个数据表，名为 tb1
    id            int           NOT NULL AUTO_INCREMENT,  -- 定义一个字段，名为 id ，数据类型为 int
    name          varchar(255)  NOT NULL,
    update_time   datetime      NOT NULL,
    PRIMARY KEY (id)                                      -- 将 id 字段声明为主键
)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;                   -- 设置存储引擎为 InnoDB ，默认字符集为 utf8mb4
```
- 采用以下两种措施，可以避免重复创建某个表：
  - 如果存在同名的表，则先删掉它，再创建：
    ```sql
    DROP TABLE IF EXISTS tb1;
    CREATE TABLE tb1(...);
    ```
  - 如果不存在同名的表，才创建它：
    ```sql
    CREATE TABLE IF NOT EXISTS tb1(...);
    ```
- 拷贝一张表：
  ```sql
  create table tb2 like tb1;          -- 拷贝表结构
  insert into tb2 select * from tb1;  -- 拷贝每行数据
  ```
- 创建临时表：
  ```sql
  create temporary table tb1(...);
  ```
  - 当客户端关闭连接时，临时表会被自动删除。
  - 执行 `show tables;` 命令时看不到临时表，必须要指定表名才能看到临时表。

#### column

- 创建数据表时需要定义它包含哪些列（column），即每行数据由哪些字段（field）组成。
  - 假设一个数据表定义了 a、b、c 三个列，则表中的每行数据都需要有这些字段，并按列对齐。
  - 创建数据表时，至少要定义一个字段。
  - 创建数据表之后，可以增加字段。也可以修改已有的字段的配置，不过这会影响已有的所有数据行的该字段的值，可能不兼容。
- 定义字段时，可以添加多种配置，如下：
  ```sql
  id int                -- 指定字段名、数据类型
        default null    -- 设置该字段的默认值，比如 default 0
        not null        -- 不允许写入的值为 null ，否则会报错
        AUTO_INCREMENT  -- 让写入的值自动递增
        comment '编号'  -- 添加注释
  ```
  - 建议给每个字段设置默认值，并且不允许值为 null 。
- MySQL 中的 null 是一个特殊的值，比空字符更占存储空间，不能使用通用的查询语句，还不利于索引优化。
  - 判断一个字段的值是否为 null ，只能用 `is null` 或 `is not null` ，返回的结果为 1 或 0 。不能用 `= null` 或 `!= null` ，否则返回的结果总是为 null 。
- 一个数据表中最多声明一个主键，也可以不声明主键。
  - 用 `PRIMARY KEY (id)` 的格式即可将一个字段声明为主键。
  - 用 `PRIMARY KEY (id, name)` 的格式可以将多个字段声明为主键，称为复合主键。
  - MySQL 规定了主键必须定义为 NOT NULL 。
  - 只有主键字段能定义成 AUTO_INCREMENT 。此时，如果新增的一行新数据中，主键字段为空或 null ，则 MySQL 会自动填写主键的值，等于前一个主键的值加一。

### 改

```sql
alter table tb1 rename to tb2;        -- 修改数据表的名字
alter table tb1 engine = myisam;      -- 修改数据表的引擎

alter table tb1 add time date;        -- 添加一个列（默认排在最后一列），列名为 time ，数据类型为 date
                [FIRST]               -- 排在第一列
                [AFTER <field>]       -- 排在指定列之后
alter table tb1 change time `t` date; -- 将 time 列改名为 t ，数据类型为 date
alter table tb1 modify time char(10); -- 修改一个字段的定义
alter table tb1 drop   time;          -- 删除一个字段
```
- MySQL 不支持重命名数据库，但可以跨库移动表：
  ```sql
  alter table db1.tb1 rename to db2.tb1;
  ```

### 删

```sql
drop table tb1;   -- 删除数据表
```

### 视图

- MySQL 支持创建视图（View）：根据一条 SELECT 语句的查询结果，生成虚拟的数据表。
  - 视图也属于数据表，但不会实际存储。
  - 视图的 SELECT 目标可以是多个数据表或视图，但不能是 temporary 表。
- 用法：
  ```sql
  CREATE VIEW <view> AS SELECT ...;   -- 创建一个视图
  SELECT * from <view>;               -- 查看视图的内容
  ALTER VIEW <view> AS SELECT ...;    -- 修改视图的 SELECT 语句
  DROP  VIEW <view>;                  -- 删除视图
  ```

## 数据行

### 查

```sql
select <field>... from <tb>...                    -- 从一个或多个数据表中，获取每行数据的指定字段
                    [where ...]                   -- 查询条件
                    [order by <filed>...]         -- 按指定字段的取值排序
                    [limit <n>]                   -- 最多返回 n 条数据
                    [limit <offset,n>]            -- 返回从第 offset 条开始的数据（从 0 开始编号），最多返回 n 条
                    [limit <n> offset <int>]      -- 另一种语法
```
- order by 子句可按多个字段进行排序：
  ```sql
  select * from tb1 order by id,name;           -- 先按 id 字段排序，如果某两条数据的 id 值相同，再按 name 字段排序
  select * from tb1 order by id asc,name desc;  -- 默认按字段取值的升序（asc）排列。对某个字段加上 desc 后缀，则采用降序
  ```
- 一次查询的数据量过大时，会消耗过多时间、内存。此时可改为分页查询：用同一查询条件多次查询，每次通过 limit 只获取部分数据，下一次从 offset 处继续获取数据，直到获取全部数据。

#### select

- select 语句用于获取、计算一个数据，默认打印到终端，像 Linux 的 echo 命令。例如：
  ```sql
  select 'Hello';          -- 打印一个字符串

  select (1 + 2 - 3)*4;     -- 可进行算术运算
  select 10/3;              -- 除法运算。该例结果为：3.3333
  select 10%3;              -- 取模运算。该例结果为：1
  ```
  ```sql
  mysql> select 10/3 > 3;   -- 比较运算的结果为 1 或 0 ，表示 true 或 false
  +----------+
  | 10/3 > 3 |
  +----------+
  |        1 |
  +----------+
  1 row in set (0.00 sec)
  ```
- select 语句可以独立执行，也可以附加 from、where、order by、limit 等子句（clause），实现多种语法功能。例如：
  ```sql
  select 'Hello';          -- 打印一个字符串

  select id from tb1;               -- 获取数据表 tb1 中的 id 字段
  select id,name from tb1;          -- 获取多个字段
  select * from tb1;                -- 使用通配符 * 获取所有字段
  select distinct * from tb1;       -- select distinct 会对返回的结果进行去重，保证每一行数据的取值不重复

  select * from tb1 where id=1;     -- 获取数据表 tb1 中，符合 where 查询条件的所有数据
  select * from tb1 where id=1 order by id limit 10 offset 0;

  select tb1.id from tb1,tb2;       -- 同时处理多个数据表时，需要注明字段所属的数据表
  select tb1.id from tb1,db2.tb2;   -- 同时处理多个数据库时，需要注明数据表所属的数据库，否则默认是指当前数据库
  ```

- 用 as 关键字，可以为 select 获取的字段、字符串增加别名：
  ```sql
  select id as field1 from tb1;
  select CONCAT('hello', ' ', 'world') as a;
  ```

#### where

- where 子句用于根据字段的值，查询、筛选数据表中的各条数据。例：
  ```sql
  where id=1;                   -- 严格匹配
  where name is null;           -- 判断 null 值

  where id>1;                   -- 使用比较运算符：=、!=、<、>、<=、>=，另外 <> 等价于 !=
  where id between 0 and 10     -- 按取值范围查询，相当于 where id>=0 and id<=10
  where id in (1, 2);           -- 使用 in 运算符，相当于 where id=1 or id=2
  where id not in (1, 2);       -- 使用 not 运算符，否定一个查询条件，进行反向查询

  where id=1 and name='one';    -- 使用 and 运算符，对两个查询条件取交集
  where id=1 or name='one';     -- 使用 or 运算符，对两个查询条件取并集
  where (... or ...) and ...;   -- 同时使用多个 and、or 运算符时，建议加上括号，区分优先级
  ```

- 比较字符串时，有两种匹配语法：
  ```sql
  where name like '<pattern>';      -- 字符串的模糊匹配，判断 pattern 是否匹配 name 字段的值
  where name REGEXP '<pattern>';    -- 字符串的正则匹配
  ```
  - 在模糊匹配的 pattern 中，可用 % 匹配 0 个、1 个或多个任意字符，用 `_` 匹配单个任意字符。如下：
    ```sql
    select '' like '%';         -- 结果为：1
    select 'hello' like '%e%';  -- 结果为：1

    select '' like '_';         -- 结果为：1
    select '1' like '_';        -- 结果为：0
    select '11' like '_';       -- 结果为：0
    ```
    - '%' 可以匹配空字符串 '' ，但不能匹配 null 。
  - 模糊匹配要求 pattern 匹配目标字符串的整体值，而正则匹配要求 pattern 匹配目标字符串的部分值。如下：
    ```sql
    select 'hello' like 'he';   -- 结果为：0
    select 'hello' REGEXP 'he'; -- 结果为：1
    ```
  - 模糊匹配、正则匹配默认不区分大小写，除非加上 binary 关键字。如下：
    ```sql
    select 'hello' like 'Hello';        -- 结果为：1
    select 'hello' like binary 'Hello'; -- 结果为：0
    ```
  - SQL 从客户端传输到服务器时，一些会解释一次转义字符，比如将 `\t` 解释为制表符。因此在正则匹配的 pattern 中使用保留字符、转义字符时，需要再加一个反斜杠前缀。如下：
    ```sql
    -- 以下匹配结果都为 1
    select 'a%b' like 'a\%b';     -- % 在模糊匹配的 pattern 中是保留字符，用 \% 可匹配一个普通的百分号 % ，而不是用作通配符
    select '\\' like '\\';        -- \ 在 MySQL 所有字符串中都是保留字符，因此要写作转义字符 \\
    select '\\' REGEXP '\\\\';    -- 在正则表达式中，用 \\\\ 才能匹配一个 \\ ，即一个被转义的 \
    select 'hello' REGEXP 'he\\w+';
    ```

### 增

```sql
insert into tb1 values (null, 'one', '2020-12-01');         -- 插入一行数据，给所有字段赋值
insert into tb1 (name, date) values ('one', '2020-12-01');  -- 插入一行数据，只给部分字段赋值，其它字段会采用默认值
```

### 改

```sql
update <tb> set <field>=<value>... [where ...];
```
- 例：
  ```sql
  update tb1 set name='one' where id=1;
  update tb1 set name='one', date='2020-12-02' where id=1;
  ```
- 修改数据行时，可以只修改某个字段。删除数据行时，会删除这行数据的全部字段。

### 删

```sql
delete from <tb>;           -- 删除数据表的全部行
delete from <tb> where ...; -- 只删除匹配查询条件的数据行

truncate [table] <tb>;      -- 先 drop 表，然后重新创建表。这样清空一张表，比 delete 语句更快
```
