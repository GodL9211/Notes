# 查询

本文记录查询 MySQL 数据行的相关知识。

## SELECT

- SELECT 语句用于获取、计算一个值，默认打印到终端，像 Linux 的 echo 命令。例如：
  ```sql
  SELECT 'Hello';          -- 打印一个字符串

  SELECT (1 + 2 - 3)*4;     -- 可进行算术运算
  SELECT 10/3;              -- 除法运算。该例结果为：3.3333
  SELECT 10%3;              -- 取模运算。该例结果为：1
  ```
  ```sql
  mysql> SELECT 10/3 > 3;   -- 比较运算的结果为 1 或 0 ，表示 true 或 false
  +----------+
  | 10/3 > 3 |
  +----------+
  |        1 |
  +----------+
  1 row in set (0.00 sec)
  ```
- SELECT 语句可以独立执行，也可以附加 FROM、WHERE 等子句（clause），实现多种语法功能。
  - 同时存在多种子句时，要按 FROM、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT 的顺序排列。

### AS

- SELECT 语句中，可以用 AS 关键字创建别名。
- 例：
  ```sql
  SELECT ROUND(10/3) AS a;
  SELECT id AS field1 FROM tb1;
  SELECT id AS field1 FROM tb1 AS table1;
  ```

### FROM

- `SELECT <field>... FROM <table>...` 用于获取一个或多个数据表中，每条数据的指定字段。
- 例：
  ```sql
  SELECT id FROM tb1;               -- 获取数据表 tb1 中的 id 字段
  SELECT id,name FROM tb1;          -- 获取多个字段
  SELECT * FROM tb1;                -- 使用通配符 * 获取所有字段
  SELECT DISTINCT name FROM tb1;    -- SELECT DISTINCT 会对返回的结果进行去重，保证每一行数据的取值不重复，包括取值为 null 的情况
  ```

### WHERE

- SELECT FROM 默认会返回数据表中的每条数据的指定字段。可加上 WHERE 子句，只返回匹配查询条件的那些条数据的字段。
  - UPDATE 语句也可加上 WHERE 子句，只修改匹配查询条件的那些条数据。
- 例：
  ```sql
  SELECT id,name FROM tb1 WHERE id=1;     -- 获取数据表 tb1 中，字段 id 取值为 1 的那条数据的指定字段

  WHERE id=1;                   -- 严格匹配
  WHERE id is null;             -- 判断 null 值

  WHERE id>1;                   -- 使用比较运算符：=、!=、<、>、<=、>=，另外 <> 等价于 !=
  WHERE id BETWEEN 0 AND 10;    -- 按取值范围查询，相当于 WHERE id>=0 AND id<=10
  WHERE id IN (1, 2);           -- 使用 IN 运算符，相当于 WHERE id=1 OR id=2
  WHERE id NOT IN (1, 2);       -- 使用 NOT 运算符，否定一个查询条件，进行反向查询

  WHERE id=1 AND name='one';    -- 使用 AND 运算符，对两个查询条件取交集
  WHERE id=1 OR name='one';     -- 使用 OR 运算符，对两个查询条件取并集
  WHERE (... OR ...) AND ...;   -- 同时使用多个 AND、OR 运算符时，建议加上括号，区分优先级
  ```

- 比较字符串时，有两种匹配语法：
  ```sql
  WHERE name LIKE '<pattern>';      -- 字符串的模糊匹配，判断 pattern 是否匹配 name 字段的值
  WHERE name REGEXP '<pattern>';    -- 字符串的正则匹配
  ```
  - 在模糊匹配的 pattern 中，可用 % 匹配 0 个、1 个或多个任意字符，用 `_` 匹配单个任意字符。如下：
    ```sql
    SELECT '' LIKE '%';         -- 结果为：1
    SELECT 'hello' LIKE '%e%';  -- 结果为：1

    SELECT '' LIKE '_';         -- 结果为：1
    SELECT '1' LIKE '_';        -- 结果为：0
    SELECT '11' LIKE '_';       -- 结果为：0
    ```
    - '%' 可以匹配空字符串 '' ，但不能匹配 null 。
  - 模糊匹配要求 pattern 匹配目标字符串的整体值，而正则匹配要求 pattern 匹配目标字符串的部分值。如下：
    ```sql
    SELECT 'hello' LIKE 'he';   -- 结果为：0
    SELECT 'hello' REGEXP 'he'; -- 结果为：1
    ```
  - 模糊匹配、正则匹配默认不区分大小写，除非加上 binary 关键字。如下：
    ```sql
    SELECT 'hello' LIKE 'Hello';        -- 结果为：1
    SELECT 'hello' LIKE binary 'Hello'; -- 结果为：0
    ```
  - SQL 从客户端传输到服务器时，一些会解释一次转义字符，比如将 `\t` 解释为制表符。因此在正则匹配的 pattern 中使用保留字符、转义字符时，需要再加一个反斜杠前缀。如下：
    ```sql
    -- 以下匹配结果都为 1
    SELECT 'a%b' LIKE 'a\%b';     -- % 在模糊匹配的 pattern 中是保留字符，用 \% 可匹配一个普通的百分号 % ，而不是用作通配符
    SELECT '\\' LIKE '\\';        -- \ 在 MySQL 所有字符串中都是保留字符，因此要写作转义字符 \\
    SELECT '\\' REGEXP '\\\\';    -- 在正则表达式中，用 \\\\ 才能匹配一个 \\ ，即一个被转义的 \
    SELECT 'hello' REGEXP 'he\\w+';
    ```

### GROUP BY

- SELECT FROM 获取一些数据时，可加上 GROUP BY 子句，将数据分成几组，从而能分组统计。
- 例：
  ```sql
  SELECT name FROM tb1 GROUP BY name;
  ```
  - 这会获取 tb1 表中的所有条数据，然后根据 name 字段取值的不同，将所有数据分成几组，每组至少包含一条数据。然后对每组执行 `SELECT name` 。
  - 上例相当于 `SELECT DISTINCT name FROM tb1;` 。如果存在 null 值，则也会创建一个分组。

- 例：
  ```sql
  SELECT name,count(*) FROM tb1 GROUP BY name;    -- 按 name 字段分组，并统计每组的数量
  SELECT name,count(*) AS num FROM tb1 GROUP BY name HAVING num>2;  -- HAVING 子句的功能像 WHERE 子句，但专用于筛选 GROUP BY 分组之后的数据
  ```

### ORDER BY

- SELECT FROM 获取一些数据时，默认按读取的先后顺序返回这些数据。可加上 ORDER BY 子句，按指定字段的值进行排序，然后才返回。
- 例：
  ```sql
  SELECT * FROM tb1 ORDER BY id,name;           -- 先按 id 字段排序，如果某两条数据的 id 值相同，再按 name 字段排序
  SELECT * FROM tb1 ORDER BY id ASC,name DESC;  -- 默认按字段取值的升序（ASC）排列。对某个字段加上 DESC 后缀，则采用降序
  ```

### LIMIT

- SELECT FROM 获取一些数据时，默认会全部返回。可加上 LIMIT 子句，只返回 n 条数据。
- 语法：
  ```sql
  SELECT <field>... FROM <table>...
                      [LIMIT <n>]                   -- 最多返回 n 条数据
                      [LIMIT <offset,n>]            -- 返回从第 offset 条开始的数据（从 0 开始编号），最多返回 n 条
                      [LIMIT <n> OFFSET <int>]      -- 另一种语法
  ```
- 例：
  ```sql
  SELECT * FROM tb1 WHERE name LIKE 'a%' LIMIT 10;
  SELECT * FROM tb1 WHERE name LIKE 'a%' ORDER BY id LIMIT 10 OFFSET 0;
  ```
- 一次查询的数据量过大时，会消耗过多时间、内存。此时可改为分页查询：用同一查询条件多次查询，每次通过 LIMIT 只获取部分数据，下一次从 offset 处继续获取数据，直到获取全部数据。

### 子查询

- 可以将一个 SELECT 语句嵌套在另一个 SELECT 语句中，称为子查询（subquery）。
- 例：
  ```sql
  SELECT name FROM tb1 WHERE name IN ( SELECT name FROM tb2 );   -- 查询在 tb1、tb2 表中同时存在的 name
  ```
  - 嵌套的子语句不能加分号 ; ，只能在最外层加分号 ; 结尾。

### JOIN

- SELECT 可以同时处理多个数据库、数据表，此时建议加上限定符前缀，避免歧义。如下：
  ```sql
  SELECT id FROM tb1,tb2;           -- 同时处理多个数据表，如果 id 字段在多个数据表存在，则会报错：Column 'id' in field list is ambiguous
  SELECT tb1.id FROM tb1,tb2;       -- 建议注明每个字段所属的数据表，既避免了报错 ambiguous ，又方便阅读
  SELECT tb1.id FROM tb1,db2.tb2;   -- 同时处理多个数据库，建议注明数据表所属的数据库，否则默认是指当前数据库
  ```

- SELECT 语句加上 JOIN 子句，可以将多个数据表的数据组合之后再查询，称为联结查询。
  - 联结查询时，会将 tb1 表的每行数据与 tb2 表的每行数据组合成一行，得到 tb1_rows * tb2_rows 个组合行，称为两个集合相乘的笛卡尔积。然后在笛卡尔积中查询数据。
  - 例：
    ```sql
    mysql> SELECT * FROM author;
    +----+--------+
    | id | author |
    +----+--------+
    |  1 | alice  |
    |  2 | bill   |
    +----+--------+
    2 rows in set (0.00 sec)

    mysql> SELECT * FROM books;
    +----+----------+-----------+
    | id | book     | author_id |
    +----+----------+-----------+
    |  1 | cookbook |         1 |
    +----+----------+-----------+
    1 row in set (0.00 sec)

    mysql> SELECT * FROM author,books WHERE author.id=books.author_id;  -- WHERE 查询
    +----+--------+----+----------+-----------+
    | id | author | id | book     | author_id |
    +----+--------+----+----------+-----------+
    |  1 | alice  |  1 | cookbook |         1 |
    +----+--------+----+----------+-----------+
    1 row in set (0.00 sec)

    mysql> SELECT * FROM author INNER JOIN books ON author.id=books.author_id;  -- 内联结查询
    +----+--------+----+----------+-----------+
    | id | author | id | book     | author_id |
    +----+--------+----+----------+-----------+
    |  1 | alice  |  1 | cookbook |         1 |
    +----+--------+----+----------+-----------+
    1 row in set (0.00 sec)

    mysql> SELECT * FROM author INNER JOIN books; -- 内联结时如果没有 ON 匹配条件，则会直接返回笛卡尔积的所有组合行
    +----+--------+----+----------+-----------+
    | id | author | id | book     | author_id |
    +----+--------+----+----------+-----------+
    |  1 | alice  |  1 | cookbook |         1 |
    |  2 | bill   |  1 | cookbook |         1 |
    +----+--------+----+----------+-----------+
    2 rows in set (0.00 sec)
    ```

#### 内联结

- ：生成两个表的笛卡尔积，返回匹配 ON 条件的那些行，即两个集合的交集。
- MySQL 中，内联结可写作 `JOIN`、`INNER JOIN`、`CROSS JOIN` 。
- 内联结可不加 ON 条件，而左联结、右联结必须有 ON 条件。

#### 左联结

- ：返回左侧表的全部数据行。每行如果匹配 ON 条件，则加上右侧表对应一行的字段。如果不匹配 ON 条件，则依然加上右侧表的一行字段，但每个字段的值为 null 。
- 例：
  ```sql
  mysql> SELECT * FROM author LEFT JOIN books ON author.id=books.author_id;
  +----+--------+------+----------+-----------+
  | id | author | id   | book     | author_id |
  +----+--------+------+----------+-----------+
  |  1 | alice  |    1 | cookbook |         1 |
  |  2 | bill   | NULL | NULL     |      NULL |
  +----+--------+------+----------+-----------+
  2 rows in set (0.00 sec)
  ```

#### 右联结

- ：返回右侧表的全部数据行。每行如果匹配 ON 条件，则加上左侧表对应一行的字段。如果不匹配 ON 条件，则依然加上左侧表的一行字段，但每个字段的值为 null 。
- 例：
  ```sql
  mysql> SELECT * FROM author RIGHT JOIN books ON author.id=books.author_id;
  +------+--------+----+----------+-----------+
  | id   | author | id | book     | author_id |
  +------+--------+----+----------+-----------+
  |    1 | alice  |  1 | cookbook |         1 |
  +------+--------+----+----------+-----------+
  1 row in set (0.01 sec)
  ```

#### 外联结

- ：相当于将左联结、右联结的结果合并为一张表。
- 可以用 `LEFT OUTER JOIN` 或 `RIGHT OUTER JOIN` ，将左联结、右联结声明为外联结。
- 例：
  ```sql
  mysql> SELECT * FROM author LEFT OUTER JOIN books ON author.id=books.author_id;
  +----+--------+------+----------+-----------+
  | id | author | id   | book     | author_id |
  +----+--------+------+----------+-----------+
  |  1 | alice  |    1 | cookbook |         1 |
  |  2 | bill   | NULL | NULL     |      NULL |
  +----+--------+------+----------+-----------+
  2 rows in set (0.00 sec)

  mysql> SELECT * FROM author RIGHT OUTER JOIN books ON author.id=books.author_id;
  +------+--------+----+----------+-----------+
  | id   | author | id | book     | author_id |
  +------+--------+----+----------+-----------+
  |    1 | alice  |  1 | cookbook |         1 |
  +------+--------+----+----------+-----------+
  1 row in set (0.00 sec)
  ```

#### 自然联结

- ：生成两个表的笛卡尔积时，将同名的列重叠成一列，其它列依然组合。
- 内联结都属于自然联结。
- 可以用 `NATURAL LEFT JOIN` 或 `NATURAL RIGHT JOIN` ，将左联结、右联结声明为自然联结，此时不允许加 ON 条件。
- 例：
  ```sql
  mysql> SELECT * FROM author NATURAL LEFT JOIN books;
  +----+--------+----------+-----------+
  | id | author | book     | author_id |
  +----+--------+----------+-----------+
  |  1 | alice  | cookbook |         1 |
  |  2 | bill   | NULL     |      NULL |
  +----+--------+----------+-----------+
  2 rows in set (0.00 sec)

  mysql> SELECT * FROM author NATURAL LEFT OUTER JOIN books;  -- 可以将一个联结同时用 NATURAL、OUTER 声明
  +----+--------+----------+-----------+
  | id | author | book     | author_id |
  +----+--------+----------+-----------+
  |  1 | alice  | cookbook |         1 |
  |  2 | bill   | NULL     |      NULL |
  +----+--------+----------+-----------+
  2 rows in set (0.00 sec)
  ```

#### 自联结

- ：对同一个表进行联结查询。
- 例：查询 books 表中，书名以 c 开头的作者，总共写了哪些书
  ```sql
  SELECT * FROM books WHERE author in (SELECT author FROM books WHERE name LIKE 'c%');   -- 属于子查询
  SELECT tb1.* FROM books AS tb1, books AS tb2 WHERE tb1.author=tb2.author AND tb2.name LIKE 'c%'; -- 属于自联结
  ```

## 函数

### 关于字符串

```sql
SELECT ASCII('hello');    -- 返回第一个字符的 ASCII 码
-> 104

SELECT RTRIM(' hello ');  -- 去除字符串右侧的空字符
SELECT LTRIM(' hello ');  -- 去除字符串左侧的空字符
SELECT TRIM(' hello ');   -- 去除字符串两侧的空字符

SELECT UPPER('Hello');    -- 将每个字符转换为大写
-> HELLO
SELECT LOWER('Hello');    -- 将每个字符转换为小写
-> hello

SELECT LENGTH('hello');           -- 返回字符串的长度
-> 5
SELECT SUBSTRING('hello', 1);     -- 返回字符串的子串，从第 1 个字符开始的所有字符
-> hello
SELECT SUBSTRING('hello', 1, 2);  -- 返回字符串的子串，从第 1 个字符开始的最多 2 个字符
-> he

SELECT CONCAT('a', 'b', 'c');         -- 将多个字符串拼接为一个字符串
-> a,b,c
SELECT CONCAT_WS(',', 'a', 'b', 'c'); -- 用分隔符拼接字符串
-> abc
```

### 关于数学

```sql
SELECT RAND();              -- 返回一个随机数，取值范围为 0~1
-> 0.5708063892748266

SELECT ABS(-3.14);          -- 计算绝对值
-> 3.14
SELECT ABS('-3.14');        -- MySQL 支持将字符串自动转换成数值
-> 3.14
SELECT ABS('hello');        -- 如果字符串不能转换成数值，则当作 0 处理
-> 0

SELECT ROUND(3.5);          -- 取整，默认保留 0 位小数，多余的小数位会四舍五入
-> 4
SELECT ROUND(3.146, 1);     -- 保留 n 位小数时，只会对第 n+1 位进行四舍五入，不会考虑全部小数位
-> 3.1
SELECT FORMAT(3.15, 1);     -- 格式化数值，保留 1 位小数，多余的小数位会四舍五入
-> 3.12
SELECT FORMAT(3.15, 3);     -- 保留 3 位小数，不足的小数位会用 0 填充
-> 3.150
SELECT TRUNCATE(3.15, 1);   -- 保留 1 位小数，不会四舍五入
-> 3.1
SELECT CEIL(3.14);          -- 返回大于等于 3.14 的最小整数
-> 4
SELECT FLOOR(3.14);         -- 返回小于等于 3.14 的最小整数
-> 3

SELECT POW(9, 0.5);         -- 计算 2 的 0.5 次幂
-> 3
SELECT POW(4, -0.5);        -- 幂指数可以是负数、小数
-> 0.5
```

```sql
SELECT COUNT(*) FROM tb1;             -- 计算数据表中有多少行数据。此时会自动使用聚集索引，或开销更小的二级索引，避免全表扫描
SELECT COUNT(*) FROM tb1 WHERE name='one';  -- COUNT(*) 加 WHERE 子句时，需要分析查询条件是否使用索引
SELECT COUNT(id) FROM tb1;            -- 计算 id 字段有多少个取值，不包括取值为 null 的情况
SELECT COUNT(DISTINCT  id) FROM tb1;  -- 计算 id 字段有多少个不重复的取值，不包括取值为 null 的情况

SELECT AVG(id) FROM tb1;    -- 计算 id 字段的平均值
SELECT SUM(id) FROM tb1;    -- 总和
SELECT MAX(id) FROM tb1;    -- 最大值
SELECT MIN(id) FROM tb1;    -- 最小值
SELECT MIN(id) AS min_id, MAX(id) AS max_id FROM tb1; -- 可同时计算多个统计值
```

### 关于时间

```sql
SELECT NOW();                   -- 返回当前的时间字符串，采用默认格式
-> 2020-01-01 12:15:05
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');   -- 返回指定格式的时间字符串
-> 2020-01-01 12:15:05
SELECT DAY('2020-01-01');       -- 提取时间中的年份，类似的函数有 YEAR()、MONTH()、DAY()、WEEKDAY()、HOUR()、SECOND()
-> 2020

SELECT TO_DAYS('2020-01-01');   -- 将指定时间转换成天数，以公元 0 年为起点
-> 737790
SELECT UNIX_TIMESTAMP(NOW());   -- 将指定时间转换成 Unix 时间戳，单位为秒
-> 1577852105
SELECT ROUND((UNIX_TIMESTAMP('2020-01-01 12:15:05') - UNIX_TIMESTAMP('2020-01-01 11:15:05')) / 60);   -- 计算两个时间相差的秒数
-> 60
SELECT TIMESTAMPDIFF(HOUR, '2020-01-01', '2020-01-02');   -- 计算第二个时间减去第一个时间的差值，单位为 HOUR
-> 24

SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);   -- 在指定时刻的基础上，增减一段时间
-> 2020-01-11
SELECT DATE_ADD('2020-01-01', INTERVAL -1 HOUR);
-> 2019-12-31 23:00:00
```

### 其它函数

```sql
SELECT VERSION();       -- 返回服务器的版本号
-> 8.0.15-12
SELECT DATABASE();      -- 返回当前数据库
-> mysql
SELECT CURRENT_USER();  -- 返回当前登录的账户名
-> test@%
SELECT SESSION_USER();  -- 返回当前会话的客户端地址
-> test@10.42.1.2

SELECT IF(1>0, 'true', 'false');    -- 如果表达式为真，则返回第一个字符串，否则返回第二个字符串
-> true
```

## 索引

- MySQL 中的索引称为 index、key ，索引中的每条数据称为条目（entry）。
  - 用户可以对一张数据表的任意个字段建立任意个单列索引、组合索引，然后在 WHERE 子句中，刻意使用已建立索引的字段作为查询条件，MySQL 便会自动使用索引加速查询，避免全表扫描。
  - 创建索引之后，MySQL 会自动保存、更新索引，不需要用户手动编辑。

### 单列索引

- 可以对一张数据表的单个列字段建立一个索引，称为单列索引（column index）。
  - 适合只考虑一个字段的查询语句，比如：`WHERE name='one'`
- 例：
  ```sql
  CREATE TABLE tb1 (..., INDEX index1(name)); -- 创建表 tb1 时，对字段 name 建立索引，命名为 index1

  CREATE INDEX index1 ON tb1(name);           -- 给表添加索引
  ALTER TABLE tb1 ADD  INDEX index1(name);    -- 另一种添加索引的语法
  ALTER TABLE tb1 DROP INDEX index1;          -- 删除表的索引

  SHOW INDEX FROM tb1;                        -- 显示表的所有索引
  ```

### 组合索引

- 可以对一张数据表的多个列字段建立一个索引，称为组合索引（composite index）。
  - 组合索引适合同时考虑多个字段的查询语句，比如：`WHERE id>1 AND name='one'`
- 例：
  ```sql
  ALTER TABLE tb1 ADD INDEX index1(id, name(10), age);
  ```
- WHERE 子句中同时查询多个字段时，比如 `WHERE a=xx AND b=xx;` ，MySQL 会将这些字段组合为一个 group ，比如 (a,b) ，然后检查能否使用 composite index ：
  - 如果 group 中存在 composite index 的第一个字段，并且 group 中的所有字段都包含于 composite index ，则可以使用该 composite index 。

- 假设 tb1 表中只有组合索引 index1(a, b, c) ，分析以下查询语句：
  ```sql
  -- 以下查询会使用 index1
  EXPLAIN SELECT * FROM tb1 WHERE a=xx;
  EXPLAIN SELECT * FROM tb1 WHERE a=xx AND b=xx;
  EXPLAIN SELECT * FROM tb1 WHERE b=xx AND a=xx;  -- AND 两侧的字段顺序不重要， (a,b) 和 (b,a) 两种字段组合的效果一样
  EXPLAIN SELECT * FROM tb1 WHERE a=xx AND c=xx;  -- a、c 不是 index1(a, b, c) 中的连续字段，也可以使用组合索引

  -- 以下查询不会使用 index1
  EXPLAIN SELECT * FROM tb1 WHERE b=xx;           -- 字段 b 不是 index1(a, b, c) 中的第一个字段
  EXPLAIN SELECT * FROM tb1 WHERE b=xx AND c=xx;  -- 字段组合 (b, c) 不包含 index1(a, b, c) 中的第一个字段
  EXPLAIN SELECT * FROM tb1 WHERE a=xx OR b=xx;   -- OR 两侧的字段不能组合为一个 group ，不能使用组合索引。虽然 WHERE a=xx 可使用租户索引，但这里 SELECT * 需要回表查询，因此不使用索引，查询类型为 all
  ```

### 前缀索引

- 对 char、varchar 等字符串型的字段建立索引时，可以限制只对左侧连续 n 个字符建立索引，称为前缀索引（prefix index）。
  - text、blob 类型的字段可能长度很大，因此只允许使用前缀索引。
- 例：
  ```sql
  ALTER TABLE tb1 ADD INDEX index1(name(5));
  ```
- n 越小，索引体积越小。
  - n 不能过小，避免查询结果的精度过低，查询一条数据却返回多条数据。
  - 一般的 InnoDB 表，index prefix 最大存储长度为 767 bytes 。存储 utf8mb4 字符时每个字符占 4 bytes ，因此 n 最大取值为 191 。
  - 如果查询语句中的值，长度超过前缀索引的 n ，比如 `WHERE name LIKE 'one%'` 。则先查询索引，找到一批前缀匹配的数据，再从原表读取这些数据的完整值，进行查询。

### 唯一索引

- 创建索引时，可以加上 unique 关键字，保证索引中每条数据的取值都不同，称为唯一索引（unique index）。
  - 如果用户向数据表写入一条索引值重复的数据，则会报错：Duplicate entry
  - 支持将前缀索引声明为 unique 。
- 例：
  ```sql
  ALTER TABLE tb1 ADD UNIQUE INDEX index1(name(5));
  ```

### 全文索引

- 创建索引时，可以加上 fulltext 关键字，对 char、varchar、text 类型的字段建立全文索引（fulltext index），方便在大型文本中搜索一个字符串。
  - 全文索引采用倒排结构，而不是 B+ tree 。
  - 不支持将前缀索引声明为全文索引。
- 例：
  ```sql
  ALTER TABLE tb1 ADD FULLTEXT INDEX index1(name);
  ```

### 主索引

- 每个 InnoDB 数据表在创建时，都会自动建立一个聚集索引（clustered index），又称为主索引（primary index），用于将数据表的所有数据行按 B+ tree 等数据结构存储。
  - 如果数据表定义了主键（PRIMARY KEY），则会根据主键建立主索引。
    - 假设主键为 id 字段，如果查询 `WHERE id=xx` ，则能很快地在主索引中定位这条数据。如果查询 `WHERE name=xx` ，则只能遍历全部数据，才能找到符合查询条件的数据。
    - 因此建议为每个数据表定义主键，以便建立主索引。
  - 如果数据表未定义主键：
    - 如果存在一个唯一索引，其中所有字段都要求 NOT NULL ，则由第一个这样的唯一索引担任主索引。
    - 如果不存在这样的唯一索引，则在数据表中添加一个隐藏的列，取值为 AUTO_INCREMENT ，用于建立主索引。

- 每个数据表有且仅有一个主索引。用户可建立其它索引，统称为非聚集索引（non-clustered index）、二级索引（secondary index）。
  - 执行 `SHOW INDEX FROM <table>`会显示主索引、所有二级索引。
  - 假设数据表的主键为 id 字段，建立了一个单列索引 index1(name) ，则存储结构如下：
    - 主索引的 B+ tree 中，在叶子节点存储数据行的全部字段，可根据 id 值定位每条数据。
    - 二级索引的 B+ tree 中，在叶子节点存储每条数据的 id 字段和 name 字段。
      - 查询 `WHERE name=xx` 时，先从二级索引找到目标数据，然后根据 id 值，从主索引读取这条数据的完整字段，即回表查询，会先后查询两个索引树。
  - 主索引中，如果几条数据的主键取值连续，则它们在磁盘的存储地址也是连续的，因此访问磁盘时属于顺序读写。
    - 二级索引中，每条数据在磁盘的存储地址是离散的，因此访问磁盘时属于随机读写，读取大量数据时比主索引慢。

### EXPLAIN

- 如果在执行 SQL 命令时加上 EXPLAIN 关键字作为前缀，则会在执行 SQL 之后，分析查询过程。如下：
- 例：tb1 表中 id 字段为主键并建立了索引，分析查询过程如下
  ```sql
  mysql> EXPLAIN SELECT * FROM tb1 WHERE id='214540bee2e1dde14eec8bdcae6d3f6d';
  +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  | id | SELECT_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
  +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | tb1   | NULL       | const | PRIMARY,id    | PRIMARY | 202     | const | 1    |   100.00 |       |
  +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  ```
  显示的各列含义如下：
  - id ：EXPLAIN 显示结果的第几行。
  - partitions ：使用了分区表中的哪个分区。
  - type ：查询类型。查询速度从高到低依次分为：
    ```sh
    null        # 不必读取表或索引。比如类似 SELECT 1+1 的纯运算；数据表为空；索引字段会被 B+ tree 排序，因此类似 SELECT max(id) FROM tb1 能直接找到最大值、最小值
    system      # 表中只包含一行数据
    const       # 查询取值唯一的索引字段，找到一个匹配结果就立即返回，不必检查剩下的数据。比如 primary 或 unique 索引字段
    eq_ref      # 联表查询时，比如 SELECT * FROM tb1,tb2 WHERE tb1.id=tb.id ，如果 id 是 primary 或 unique 索引字段，则属于 eq_ref 类型
    ref         # 联表查询时，如果 id 不是 primary 或 unique 索引字段，使得 tb1 中的一条数据可能对应 tb2 中的多条数据，则属于 ref 类型
    index_merge # 使用了两个或更多索引，最后合并它们的查询结果
    range       # 查询了索引中某个取值范围的数据。比如 WHERE id>'214540bee2e1dde14eec8bdcae6d3f6d'; ，类似的运算符有 <、>、!=、between、in、is null
    index       # 遍历了索引表，检查了其中所有条数据
    all         # 遍历了原表，即全表扫描
    ```
  - possible_keys ：当前查询可能使用哪些索引。如果 WHERE 子句查询了多个字段，其中某些字段存在于已建立的索引中，则考虑是否使用这些索引。
  - key ：实际使用的索引名，可能有多个。
  - key_len ：索引表中，每条数据预计读取的长度。必须从头开始读取字节，可能不必读取到最后一个字节。
  - ref ：表示跟索引字段相比较的对象。比如一个常量、联表查询时另一张表的字段名。
  - rows  ：预计要读取多少条数据，才能找到目标数据。
  - Extra 记录一些额外信息，例如：
    ```sh
    Using index       # 只读取了索引表就返回查询结果，不必读取原表，即覆盖查询。这种情况下，查询效率最高
    Using WHERE       # 查询到数据之后，需要经过 WHERE 子句过滤，才返回给用户。这说明查询到了额外的数据，可能需要优化 SQL
    Using temporary   # 查询到数据之后，需要建立中间表来暂存。使用 group by 时通常会这样
    ```

- describe 关键字等价于 EXPLAIN ，缩写为 desc 。
- 可以主动控制是否使用索引，便于测试索引的效果：
  ```sql
  EXPLAIN SELECT * FROM tb1 USE    INDEX(index1) WHERE name='one';  -- 只使用某些索引
  EXPLAIN SELECT * FROM tb1 IGNORE INDEX(index1) WHERE name='one';  -- 忽略某些索引
  EXPLAIN SELECT * FROM tb1 FORCE  INDEX(index1) WHERE name='one';  -- 强制使用某些索引
  ```

### 使用索引

- 适合创建索引的情况：
  - 经常在 WHERE 子句中查询的字段。
  - 经常用 ORDER BY 排序的列。
    - 大部分类型的索引采用 B+ tree 存储结构，在存储时根据建立索引的字段的取值进行了排序，因此方便查找一个值、多个值、一个范围内的值。
- 不适合创建索引的情况：
  - 字段数量不多的表。因为查询时加速效果不明显。
  - 数据表经常增删数据，或者建立索引的字段的值经常修改。因为启用索引的效果是，读操作更快，写操作更慢。
  - 取值容易重复的列。因为索引的查询结果可能包含很多条数据，回表查询的耗时较久。
    - 通常字段的长度越大，取值重复率越低，但是索引体积也会越大，占用更多内存。
    - 例如字段取值为递增编号，或哈希值前几位时，长度小，并且取值几乎不会重复。但是取值缺乏意义，不方便人记忆。

- 用户执行查询语句时，MySQL 会自动判断是否使用索引，流程如下：
  1. 找到与查询字段匹配的所有索引，记作 possible_keys 。
  2. 比较 possible_keys 中的各个索引，考虑使用哪个索引。
      - 如果预期使用索引的效率比全表扫描更低，则不会使用索引。这是一条大致的原则，不一定准确，建议用 EXPLAIN 检查 SQL 是否使用了索引。
      - 如果一个字段同时匹配多个索引，比如一个单列索引、一个组合索引，则使用开销最小的那个索引。
      - 如果同时查询多个字段，这些字段匹配不同的索引，则可以分别查询这些索引，然后合并查询结果。

- 假设 tb1 表中 id 字段为主键，其它字段未建立索引，下面分析使用索引的常见情况：
  - 例：
    ```sql
    EXPLAIN SELECT id FROM tb1;   -- 没有 WHERE 查询条件，但 SELECT id 只需要读取主索引的索引键，不需要读取其它字段，因此查询类型为 index
    EXPLAIN SELECT name FROM tb1; -- 查询类型为 all ，因为 SELECT 读取的字段不是索引键
    EXPLAIN SELECT * FROM tb1;    -- 查询类型为 all ，与上一条同理

    EXPLAIN SELECT * FROM tb1 WHERE id='214540bee2e1dde14eec8bdcae6d3f6d';  -- 查询类型为 const
    EXPLAIN SELECT * FROM tb1 WHERE id>'214540bee2e1dde14eec8bdcae6d3f6d';  -- 查询类型为 range
    EXPLAIN SELECT * FROM tb1 WHERE id>1; -- 查询类型为 all ，因为 1 与 id 的数据类型不兼容，相当于没有查询条件，预计匹配所有数据，而 SELECT 的字段不支持覆盖索引，此时使用索引不如全表扫描
    EXPLAIN SELECT * FROM tb1 WHERE id is not null;   -- 查询类型为 all ，与上一条同理
    ```
  - 查询语句像 `WHERE id LIKE A` 时，如果 A 是字符串常量、且不以 % 开头，才会使用索引。
  - 查询语句像 `WHERE ... AND ...` 时，比如 `WHEREr a=1 AND b=2` ，如果只有字段 a 或 b 建立了索引，则 MySQL 会先查询该字段，筛选出数据之后再执行其它字段的查询条件。如下：
    ```sql
    -- 这两条查询语句的效果一样，查询类型为 range
    EXPLAIN SELECT id FROM tb1 WHERE id>'214540bee2e1dde14eec8bdcae6d3f6d' AND name='one';
    EXPLAIN SELECT id FROM tb1 WHERE name='one' AND id>'214540bee2e1dde14eec8bdcae6d3f6d';
    ```
  - 查询语句像 `WHERE ... OR ... AND ...` 时，如果 OR 左侧的查询没有使用索引，进行了一次全表扫描，则右侧的查询也不会使用索引。如果 OR 左侧或右侧没有使用索引，则 AND 之后的查询都不会使用索引。
