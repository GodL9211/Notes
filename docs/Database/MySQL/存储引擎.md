# 存储引擎

常见的几种存储引擎：
- MyISAM ：一个传统引擎。不支持外键、事务、行级锁，只支持表级锁。
- InnoDB ：从 MySQL 5.5 开始成为默认引擎，支持外键、事务、行级锁。
  - 一般情况下使用 InnoDB 引擎更好。

## 外键

- 可以让表 A 中的一个字段引用表 B 中的一个字段，从而让两张表的每行数据建立映射关系。该字段称为外键（foreign key）。
- 建立外键的条件：
  - 表 A 的外键字段的值在表 B 中都存在。
  - 表 B 中被引用的字段的值是 unique 的。
- 外键的几种映射关系：
  - 一对一：表 A 中的数据与表 B 中的数据一一对应。
  - 多对一：表 A 中的多条数据对应到表 B 中的一条数据。（此时，要在多的那方数据表中定义外键）
  - 多对多：表 A 中的多条数据对应到表 B 中的多条数据。（此时，可以在任意一方数据表中定义外键）
- 定义外键的例子：
    ```sql
    create table tb1(
        id int primary key auto_increment,     -- 定义 id 字段，并声明为主键
        num int not null,                      -- 定义字段 num
        foreign key(num) references tb2(id)    -- 将字段 num 声明为外键，引用 tb2 表的 id 字段
    );

    alter table tb1 add constraint num foreign key(num) references tb2(id);  -- 将字段 num 声明为外键

    alter table tb1 drop foreign key num;      -- 取消外键
    ```
  - 在 tb1 中插入一行包含外键的数据时，该外键值必须在 tb2 中存在，否则会报错。
  - 删除 tb2 之前，必须先删除 tb1 中关联到它的所有行数据。

## 索引

- MySQL 中的索引称为 index、key ，索引中的每条数据称为条目（entry）。
  - 用户可以对一张数据表的任意个字段建立任意个单列索引、组合索引，然后在 where 子句中，刻意使用已建立索引的字段作为查询条件，MySQL 便会自动使用索引加速查询，避免全表扫描。
  - 创建索引之后，MySQL 会自动保存、更新索引，不需要用户手动编辑。

### 单列索引

- 可以对一张数据表的单个列字段建立一个索引，称为单列索引（column index）。
  - 适合只考虑一个字段的查询语句，比如：`where name='one'`
- 例：
  ```sql
  create table tb1 (..., index index1(name)); -- 创建表 tb1 时，对字段 name 建立索引，命名为 index1

  create index index1 on tb1(name);           -- 给表添加索引
  alter table tb1 add  index index1(name);    -- 另一种添加索引的语法
  alter table tb1 drop index index1;          -- 删除表的索引

  show index from tb1;                        -- 显示表的所有索引
  ```

### 组合索引

- 可以对一张数据表的多个列字段建立一个索引，称为组合索引（composite index）。
  - 组合索引适合同时考虑多个字段的查询语句，比如：`where id>1 and name='one'`
- 例：
  ```sql
  alter table tb1 add index index1(id, name(10), age);
  ```
- where 子句中同时查询多个字段时，比如 `where a=xx and b=xx;` ，MySQL 会将这些字段组合为一个 group ，比如 (a,b) ，然后检查能否使用 composite index ：
  - 如果 group 中存在 composite index 的第一个字段，并且 group 中的所有字段都包含于 composite index ，则可以使用该 composite index 。

- 假设 tb1 表中只有组合索引 index1(a, b, c) ，分析以下查询语句：
  ```sql
  -- 以下查询会使用 index1
  explain select * from tb1 where a=xx;
  explain select * from tb1 where a=xx and b=xx;
  explain select * from tb1 where b=xx and a=xx;  -- and 两侧的字段顺序不重要， (a,b) 和 (b,a) 两种字段组合的效果一样
  explain select * from tb1 where a=xx and c=xx;  -- a、c 不是 index1(a, b, c) 中的连续字段，也可以使用组合索引

  -- 以下查询不会使用 index1
  explain select * from tb1 where b=xx;           -- 字段 b 不是 index1(a, b, c) 中的第一个字段
  explain select * from tb1 where b=xx and c=xx;  -- 字段组合 (b, c) 不包含 index1(a, b, c) 中的第一个字段
  explain select * from tb1 where a=xx or b=xx;   -- or 两侧的字段不能组合为一个 group ，不能使用组合索引。虽然 where a=xx 可使用租户索引，但这里 select * 需要回表查询，因此不使用索引，查询类型为 all
  ```

### 前缀索引

- 对 char、varchar 等字符串型的字段建立索引时，可以限制只对左侧连续 n 个字符建立索引，称为前缀索引（prefix index）。
  - text、blob 类型的字段可能长度很大，因此只允许使用前缀索引。
- 例：
  ```sql
  alter table tb1 add index index1(name(5));
  ```
- n 越小，索引体积越小。
  - n 不能过小，避免查询结果的精度过低，查询一条数据却返回多条数据。
  - 一般的 InnoDB 表，index prefix 最大存储长度为 767 bytes 。存储 utf8mb4 字符时每个字符占 4 bytes ，因此 n 最大取值为 191 。
  - 如果查询语句中的值，长度超过前缀索引的 n ，比如 `where name like 'one%'` 。则先查询索引，找到一批前缀匹配的数据，再从原表读取这些数据的完整值，进行查询。

### 唯一索引

- 创建索引时，可以加上 unique 关键字，保证索引中每条数据的取值都不同，称为唯一索引（unique index）。
  - 如果用户向数据表写入一条索引值重复的数据，则会报错：Duplicate entry
  - 支持将前缀索引声明为 unique 。
- 例：
  ```sql
  alter table tb1 add unique index index1(name(5));
  ```

### 全文索引

- 创建索引时，可以加上 fulltext 关键字，对 char、varchar、text 类型的字段建立全文索引（fulltext index），方便在大型文本中搜索一个字符串。
  - 全文索引采用倒排结构，而不是 B+ tree 。
  - 不支持将前缀索引声明为全文索引。
- 例：
  ```sql
  alter table tb1 add fulltext index index1(name);
  ```

### 主索引

- 每个 InnoDB 数据表在创建时，都会自动建立一个聚集索引（clustered index），又称为主索引（primary index），用于将数据表的所有数据行按 B+ tree 等数据结构存储。
  - 如果数据表定义了主键（PRIMARY KEY），则会根据主键建立主索引。
    - 假设主键为 id 字段，如果查询 `where id=xx` ，则能很快地在主索引中定位这条数据。如果查询 `where name=xx` ，则只能遍历全部数据，才能找到符合查询条件的数据。
    - 因此建议为每个数据表定义主键，以便建立主索引。
  - 如果数据表未定义主键：
    - 如果存在一个唯一索引，其中所有字段都要求 NOT NULL ，则由第一个这样的唯一索引担任主索引。
    - 如果不存在这样的唯一索引，则在数据表中添加一个隐藏的列，取值为 AUTO_INCREMENT ，用于建立主索引。

- 每个数据表有且仅有一个主索引。用户可建立其它索引，统称为非聚集索引（non-clustered index）、二级索引（secondary index）。
  - 执行 `show index from <table>`会显示主索引、所有二级索引。
  - 假设数据表的主键为 id 字段，建立了一个单列索引 index1(name) ，则存储结构如下：
    - 主索引的 B+ tree 中，在叶子节点存储数据行的全部字段，可根据 id 值定位每条数据。
    - 二级索引的 B+ tree 中，在叶子节点存储每条数据的 id 字段和 name 字段。
      - 查询 `where name=xx` 时，先从二级索引找到目标数据，然后根据 id 值，从主索引读取这条数据的完整字段，即回表查询，会先后查询两个索引树。
  - 主索引中，如果几条数据的主键取值连续，则它们在磁盘的存储地址也是连续的，因此访问磁盘时属于顺序读写。
    - 二级索引中，每条数据在磁盘的存储地址是离散的，因此访问磁盘时属于随机读写，读取大量数据时比主索引慢。

### explain

- 如果在执行 SQL 命令时加上 explain 关键字作为前缀，则会在执行 SQL 之后，分析查询过程。如下：
- 例：tb1 表中 id 字段为主键并建立了索引，分析查询过程如下
  ```sql
  mysql> explain select * from tb1 where id='214540bee2e1dde14eec8bdcae6d3f6d';
  +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
  +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | tb1   | NULL       | const | PRIMARY,id    | PRIMARY | 202     | const | 1    |   100.00 |       |
  +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  ```
  显示的各列含义如下：
  - id ：explain 显示结果的第几行。
  - partitions ：使用了分区表中的哪个分区。
  - type ：查询类型。查询速度从高到低依次分为：
    ```sh
    null        # 不必读取表或索引。比如类似 select 1+1 的纯运算；数据表为空；索引字段会被 B+ tree 排序，因此类似 select max(id) from tb1 能直接找到最大值、最小值
    system      # 表中只包含一行数据
    const       # 查询取值唯一的索引字段，找到一个匹配结果就立即返回，不必检查剩下的数据。比如 primary 或 unique 索引字段
    eq_ref      # 联表查询时，比如 SELECT * FROM tb1,tb2 WHERE tb1.id=tb.id ，如果 id 是 primary 或 unique 索引字段，则属于 eq_ref 类型
    ref         # 联表查询时，如果 id 不是 primary 或 unique 索引字段，使得 tb1 中的一条数据可能对应 tb2 中的多条数据，则属于 ref 类型
    index_merge # 使用了两个或更多索引，最后合并它们的查询结果
    range       # 查询了索引中某个取值范围的数据。比如 where id>'214540bee2e1dde14eec8bdcae6d3f6d'; ，类似的运算符有 <、>、!=、between、in、is null
    index       # 遍历了索引表，检查了其中所有条数据
    all         # 遍历了原表，即全表扫描
    ```
  - possible_keys ：当前查询可能使用哪些索引。如果 where 子句查询了多个字段，其中某些字段存在于已建立的索引中，则考虑是否使用这些索引。
  - key ：实际使用的索引名，可能有多个。
  - key_len ：索引表中，每条数据预计读取的长度。必须从头开始读取字节，可能不必读取到最后一个字节。
  - ref ：表示跟索引字段相比较的对象。比如一个常量、联表查询时另一张表的字段名。
  - rows  ：预计要读取多少条数据，才能找到目标数据。
  - Extra 记录一些额外信息，例如：
    ```sh
    Using index       # 只读取了索引表就返回查询结果，不必读取原表，即覆盖查询。这种情况下，查询效率最高
    Using where       # 查询到数据之后，需要经过 where 子句过滤，才返回给用户。这说明查询到了额外的数据，可能需要优化 SQL
    Using temporary   # 查询到数据之后，需要建立中间表来暂存。使用 group by 时通常会这样
    ```

- describe 关键字等价于 explain ，缩写为 desc 。
- 可以主动控制是否使用索引，便于测试索引的效果：
  ```sql
  explain select * from tb1 use    index(index1) where name='one';  -- 只使用某些索引
  explain select * from tb1 ignore index(index1) where name='one';  -- 忽略某些索引
  explain select * from tb1 force  index(index1) where name='one';  -- 强制使用某些索引
  ```

### 使用索引

- 适合创建索引的情况：
  - 经常在 where 子句中查询的字段。
  - 经常用 order by 排序的列。
    - 大部分类型的索引采用 B+ tree 存储结构，在存储时根据建立索引的字段的取值进行了排序，因此方便查找一个值、多个值、一个范围内的值。
- 不适合创建索引的情况：
  - 字段数量不多的表。因为查询时加速效果不明显。
  - 数据表经常增删数据，或者建立索引的字段的值经常修改。因为启用索引的效果是，读操作更快，写操作更慢。
  - 取值容易重复的列。因为索引的查询结果可能包含很多条数据，回表查询的耗时较久。
    - 通常字段的长度越大，取值重复率越低，但是索引体积也会越大，占用更多内存。
    - 例如字段取值为递增编号，或哈希值前几位时，长度小，并且取值几乎不会重复。但是取值缺乏意义，不方便人记忆。

- 用户执行查询语句时，MySQL 会自动判断是否使用索引，流程如下：
  1. 找到与查询字段匹配的所有索引，记作 possible_keys 。
  2. 比较 possible_keys 中的各个索引，考虑使用哪个索引。
      - 如果预期使用索引的效率比全表扫描更低，则不会使用索引。这是一条大致的原则，不一定准确，建议用 explain 检查 SQL 是否使用了索引。
      - 如果一个字段同时匹配多个索引，比如一个单列索引、一个组合索引，则先找到哪个索引，就用哪个。
      - 如果同时查询多个字段，这些字段匹配不同的索引，则可以分别查询这些索引，然后合并查询结果。

- 假设 tb1 表中 id 字段为主键，其它字段未建立索引，下面分析使用索引的常见情况：
  - 例：
    ```sql
    -- 没有 where 查询条件，但 select id 只需要读取主索引的索引键，不需要读取其它字段，因此查询类型为 index
    explain select id from tb1;
    -- 查询类型为 all ，因为 select name 读取的字段不是索引键
    explain select name from tb1;
    -- 查询类型为 all ，与上一条同理
    explain select * from tb1;

    -- 查询类型为 const
    explain select * from tb1 where id='214540bee2e1dde14eec8bdcae6d3f6d';
    -- 查询类型为 range
    explain select * from tb1 where id>'214540bee2e1dde14eec8bdcae6d3f6d';
    -- 查询类型为 all ，因为 1 与 id 的数据类型不兼容，相当于没有查询条件，预计匹配所有数据，而 select 的字段不支持覆盖索引，此时使用索引不如全表扫描
    explain select * from tb1 where id>1;
    -- 查询类型为 all ，与上一条同理
    explain select * from tb1 where id is not null;
    ```
  - 查询语句像 `where id like A` 时，如果 A 是字符串常量、且不以 % 开头，才会使用索引。
  - 查询语句像 `where ... and ...` 时，比如 `wherer a=1 and b=2` ，如果只有字段 a 或 b 建立了索引，则 MySQL 会先查询该字段，筛选出数据之后再执行其它字段的查询条件。如下：
    ```sql
    -- 这两条查询语句的效果一样，查询类型为 range
    explain select id from tb1 where id>'214540bee2e1dde14eec8bdcae6d3f6d' and name='one';
    explain select id from tb1 where name='one' and id>'214540bee2e1dde14eec8bdcae6d3f6d';
    ```
  - 查询语句像 `where ... or ... and ...` 时，如果 or 左侧的查询没有使用索引，进行了一次全表扫描，则右侧的查询也不会使用索引。如果 or 左侧或右侧没有使用索引，则 and 之后的查询都不会使用索引。

## 事务

- InnoDB 引擎支持事务。
- 可以将连续执行的多个 SQL 命令声明为一个事务：
  ```sql
  BEGIN;           -- 开始一个事务，也可写作 START TRANSACTION
  ...
  ROLLBACK;        -- 回滚到 BEGIN 时的状态
  ...
  SAVEPOINT p1;    -- 声明一个回滚点
  ...
  ROLLBACK TO p1;  -- 回滚到指定位置
  ...
  COMMIT;          -- 提交事务（在此之前不会自动提交）
  ```
- 相关命令：
  ```sql
  SELECT * FROM information_schema.innodb_trx;   -- 查询当前的所有事务
  SET AUTOCOMMIT=0`       -- 取消自动提交事务。默认每执行一条 SQL 命令就自动作为一个事务提交
  ```

## 数据库锁

- 关于表级锁的命令：
  ```sql
  LOCK TABLES [<tb> <lock_type>],...    -- 给指定表加锁，使当前客户端会话获得表锁，例如 LOCK TABLES tb1 WRITE, tb2 READ;
  UNLOCK TABLES                         -- 释放当前会话的所有表锁

  FLUSH TABLES                          -- 强制关闭所有被打开的表，并将写缓存中的数据写入磁盘
              tb,...                    -- 只处理指定的表
              WITH READ LOCK            -- flush 之后加上全局只读锁。这是全局锁，因此不需要获得 lock tables 的表锁

  SHOW STATUS LIKE 'Table_locks%';      -- 统计获得表锁的耗时
  ```
  - 客户端执行 `LOCK TABLES` 或 `START TRANSACTION` 时，都会隐式地释放已获得的表锁。
    - 客户端断开会话时，服务器会释放其获得的表锁。

- 关于行级锁的命令：
  ```sql
  SELECT * FROM ... WHERE ... LOCK IN SHARE MODE      -- 给查询到的所有数据行加行级共享锁
  SELECT * FROM ... WHERE ... FOR UPDATE              -- 加行级排它锁

  SHOW STATUS LIKE 'InnoDB_row_lock%';                -- 统计获得行锁的耗时
  SELECT * FROM performance_schema.data_locks;        -- 显示所有获取行锁的请求，包括已经获得的、等待获得的
  SELECT * FROM performance_schema.data_lock_waits;   -- 显示 data_lock_waits 中的哪些请求在被哪些请求阻塞
  ```
  - InnoDB 的行锁是通过给索引中的索引键加锁来实现的。
    - 如果不使用索引进行查询，则行锁不起作用，只能使用表锁。
    - 如果针对不同的数据行加行锁，却使用相同的索引键，则也会发生锁冲突。
  - InnoDB 在申请行锁时，会先隐式地申请该表的意向锁（intention lock），类型也为共享或排它。
    - 意向锁是一种特殊的表锁，表示意图对该表加行锁。
      - 意向锁不与意向锁冲突。
      - 意向共享锁与表级共享锁不冲突，其它意向锁与表级锁都冲突。
    - 意向锁由 InnoDB 自动获得、释放，客户端不能控制。
      - 使用意向锁，InnoDB 能更快地发现表级锁是否冲突。
    - 例：
      1. 事务 A 执行 `SELECT * FROM tb1 WHERE id=1 FOR UPDATE;` ，先请求获得对 tb1 表的意向排它锁，成功之后再请求获得对 id=1 的数据行的排它锁。
      2. 事务 B 执行 `SELECT * FROM tb1 WHERE id=2 FOR UPDATE;` ，与事务 A 不冲突，能够获得意向排它锁、行级排它锁。
      3. 事务 C 执行 `LOCK TABLES tb1 READ;` ，请求获得表级只读锁，但 tb1 表已有意向排它锁，因此阻塞等待。

  - InnoDB 提供的行锁属于悲观锁，用户可以自己编程实现乐观锁。如下：
    ```sql
    select name from tb1 where id = 1;                    -- 先查询下修改之前的值，这里假设此时 name 的值为 'one'
    update tb1 set name='two' where id=1 and name='one';  -- 执行之后，根据返回值判断是否修改成功
    ```
    - 可以根据 timestap 等字段来判断数据是否被修改。

- 相关配置：
  ```sh
  innodb_lock_wait_timeout = 50     # 事务请求获取 row lock 时，等待的超时时间，默认为 50s 。超时则报错：Lock wait timeout exceeded
  innodb_rollback_on_timeout = OFF  # innodb_lock_wait_timeout 时，是否回滚整个事务。默认为 OFF ，只回滚最后一条语句，可能破坏事务原子性
  ```

## innodb_data

- InnoDB 引擎的大部分数据都保存在系统表空间（System Tablespace）中，包括：
  - 每个表的数据页、索引
  - change buffer
  - data dictionary
  - doublewrite buffer
  - undo log
- 系统表空间在磁盘保存为一个或多个文件。
  - 早期的 InnoDB 引擎，将系统表空间都保存在 `$datadir/ibdata1` 文件中。
    - InnoDB 引擎不会减小 ibdata1 文件的体积。即使 delete 了一些数据，也不会释放磁盘空间，而是留给未来使用。
    - 可以通过 mysqldump 重建数据库，从而减小 ibdata1 文件。
  - MySQL v5.6.6 开始，默认设置了 `innodb_file_per_table=ON` ，将每个数据表的数据页、索引分别保存到 `$datadir/<db_name>/<table_name>.ibd` 文件中，而 ibdata1 文件保存其它数据。
    - 这样 drop table 时会自动释放磁盘空间。

### 表碎片

- InnoDB 表以 B+ 树结构存储数据。删除一行数据时，并不会释放存储空间，而是标记为 free ，留待以后写入新数据。这些 free 空间称为碎片（fragment）。
  - 执行 delete、update 操作可能产生碎片。
  - 如果碎片空间比新数据行体积小，则一直不会用于写入新数据。
  - 一般按 `data_free / (data_length + index_length)` 计算碎片率。
  - 如果碎片率长时间较高，建议手动清理碎片，从而减少占用的存储空间、减少读取表的耗时。

- 相关命令：
  ```sql
  -- 显示表状态，其中 Data_free 表示 free 数据占用的存储空间，单位 bytes
  show table status;

  -- 统计所有表的碎片率
  select TABLE_SCHEMA,TABLE_NAME,ENGINE,
      DATA_LENGTH/1024/1024 as data_length,
      INDEX_LENGTH/1024/1024 as index_length,
      DATA_FREE/1024/1024 as data_free,
      DATA_FREE/(DATA_LENGTH+INDEX_LENGTH) as free_rate
      from information_schema.tables where DATA_FREE/1024/1024 > 10;

  -- MyISAM 表可用该命令清理碎片，这会暂时锁定表
  optimize table <tb>...;

  -- InnoDB 表可用该命令清理碎片。这会以 Online DDL 方式拷贝出一个无碎片的新表，然后重命名为原表
  alter table <tb> engine=InnoDB;
  analyze table <tb>;
  ```
  ```sh
  mysqlcheck
      -h <host> -P <port> -u <user> -p
      -o                    # --optimize ，优化表
        <db> <tb>           # 指定数据库中的数据表
        --databases <db>... # 指定多个数据库的数据表
        --all-databases     # 指定所有数据库
  ```
