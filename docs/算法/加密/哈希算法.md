# 哈希算法

：Hash algorithm，又称为散列函数，用于对一段任意长度的数据计算摘要，生成一个散列值，又称为哈希值。
- 通常只要数据的内容不同，哈希算法生成的散列值就不同，可用作该数据的特征值，相当于签名。
  - 哈希算法的用途不是加密数据，而是生成数据的特征值。

## 常见类型

常见的几种哈希算法：
- MD5：于1992年被提出，生成128位的散列值。安全性较差，已被淘汰。
- SHA1：于1995年被提出，生成160位的散列值。安全性较差，已被淘汰。
- SHA256：生成256位的散列值。安全性较高，但是生成速度较慢。
- SHA512：生成512位的散列值。安全性更高，但是生成速度更慢。

这几种哈希算法的用法基本相同，它们的特征如下：
- 都是用于生成一段任意长度的二进制数据的Hash值。
  - 例如：处理字符串、处理图片等文件时都是先转换成二进制流，再计算其Hash值。
- 如果两个数据的内容相同，则它们的Hash值一定相同。
  - 在计算机上编辑图片等文件时可能会自动加上时间信息等内容，导致最后保存的文件内容看起来一样，实际上二进制数据并不一样，因此Hash值不同。
- 如果两个数据的内容不同（即使只有一个bit的差异），则它们的Hash值几乎总是不同。
  - 如果相同，则称为发生碰撞。哈希算法的碰撞率越低越好。
  - MD5只生成128位的散列值，因此碰撞率比SHA256高。
- 如果只知道一个数据的Hash值，则一定不能据此反推出原数据的内容。
  - 因为理论上生成同一个Hash值的原数据可能有无数种。想反推出原数据，除非哈希算法存在容易被反推的缺陷，或者建立一个庞大的数据库，存储常见的一些数据的哈希值。
- 哈希算法的用途：
  - 用于数据的一致性检验。比如生成某段数据的MD5值，如果与之前的MD5值不同，就说明该数据被篡改了。
  - 用于加密用户的密码。比如Web服务器不储存用户的明文密码，而是储存密码的MD5值，这样既可以检验用户输入的密码是否正确，还能防止Web服务器泄露用户的明文密码。

## 密码的加密

Web服务器可以将用户的密码的哈希值存储在数据库中，只要用户下次输入的密码的哈希值相同，就判断密码正确。
- 一般来说，即使密码的哈希值被泄露，Hacker也不会知道对应的明文密码。
- 不过，Hacker可能通过以下方法，暴力破解出Hash值对应的明文密码：
  - 穷举法
  - 字典法：记下人们常用的密码及其对应的Hash值。当目标Hash值与字典中某项匹配时，就可以知道对应的明文密码。
  - 彩虹表：确定哈希算法的函数H()，再拟定一个将哈希值h转换成另一个字符串p的函数R()。然后选择一个字符串p1作为起点，逐个算出h1=H(p1)、p2=R(h1)、h2=H(p2)、……，这样就得到了一条哈希链，记下其中的所有p。选取多个p1，就可以算出多条哈希链，得到一个彩虹表。想破解某个哈希值s时，就计算R(s)，到彩虹表中寻找是否有与之相同的p值。如果pn的值与R(s)相同，则s对应的明文密码就是pn-1。
    - 使用彩虹表时比字典法少了一半的存储空间，又比穷举法快。
- 针对上述破解方法，Web服务器可采用以下措施提高密码的安全性：
  - 选用Hash值更长、加密更慢的Hash算法，增加暴力破解的试错成本。
  - 每次加密密码时加上一个随机的、无法预测的“盐”，这样即使Hacker知道了服务器采用的Hash算法，也不能事先准备一个破解字典。
    - 服务器应该将每个用户的密码与盐值一起保存到数据库中。
- 判断两个Hash值是否相同时，无论结果是True还是False甚至出错，都应该控制在相同的处理时长。
  - 如果使用一般的字符串比较方法（从左到右逐位比较，遇到某一位的字符不同时就返回False），就可能被Hacker根据处理时长的微小差异逐位试出Hash值的每一位应该是什么值。
  - 使用异或运算就可以控制在相同的处理时长。比如：a ^ b == 0

## ♢ Hashlib

：Python的标准库，提供了MD5、SHA1、SHA256、SHA512等常见哈希算法的函数。

- 例：
    ```python
    >>> import Hashlib
    >>> h = Hashlib.sha256()          # 创建一个Hash对象
    >>> h.update("Hello".encode())    # 输入要Hash的内容（必须转换成bytes类型）
    >>> h.update("World".encode())    # 可以累加
    >>> h.digest()                    # 生成Hash值（也是bytes类型）
    b'\x87.NP\xce\x99\x90\xd8\xb0A3\x0cG\xc9\xdd\xd1\x1b\xeckP:\xe98j\x99\xda\x85\x84\xe9\xbb\x12\xc4'
    >>> Hashlib.sha256("HelloWorld".encode()).digest()      # 可简化成一步
    b'\x87.NP\xce\x99\x90\xd8\xb0A3\x0cG\xc9\xdd\xd1\x1b\xeckP:\xe98j\x99\xda\x85\x84\xe9\xbb\x12\xc4'
    ```
- 加盐的方法：
    ```python
    import os
    salt = os.urandom(10)      # 生成指定字节数的随机bytes对象
    password = '123456'.encode()
    Hash_bytes = salt + password
    result = Hashlib.sha256(Hash_bytes).digest()
    ```
    - 用Python的random模块生成的随机数是不安全的，此处应该用os.urandom()函数生成随机数。
 
## ♢ hmac

：Python的标准库，提供了hmac算法的加密函数。
- MAC算法是使用密钥的Hash算法。
- hmac算法使用一个key和一种Hash算法对消息进行加密，比单纯的Hash加盐更安全。
- 例：
    ```python
    >>> import hmac
    >>> key = os.urandom(10)
    >>> msg = '123456'.encode()
    >>> hmac.new(key, msg, 'sha256').digest()
    b'\xa5\x06^\xeb\xf11B\xad\x9c\x88\x88\x80\xacz\xcb\xd4K\xe2\x01\xd8\x95DD\xa8{\\:t\x19\x87\xd
    b\xfa'
    >>> hmac.compare_digest(b'123', b'123')    # 比较两个Hash值是否相同
    True
    ```
