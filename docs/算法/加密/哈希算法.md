# 哈希算法

：Hash algorithm ，又称为散列函数，用于对一段任意长度的数据计算摘要，生成一个散列值，又称为哈希值。
- 通常只要数据的内容不同，哈希算法生成的散列值就不同，可用作该数据的特征值，相当于签名。
  - 哈希算法的用途不是加密数据，而是生成数据的特征值。

## 常见类型

常见的几种哈希算法：
- MD5 ：于 1992 年被提出，生成 128 位的散列值。安全性较差，已被淘汰。
- SHA1 ：于 1995 年被提出，生成 160 位的散列值。安全性较差，已被淘汰。
- SHA256 ：生成 256 位的散列值。安全性较高，但是生成速度较慢。
- SHA512 ：生成 512 位的散列值。安全性更高，但是生成速度更慢。

这几种哈希算法的用法基本相同，它们的特征如下：
- 都是用于生成一段任意长度的二进制数据的 Hash 值。
  - 例如：处理字符串、处理图片等文件时都是先转换成二进制流，再计算其 Hash 值。
- 如果两个数据的内容相同，则它们的 Hash 值一定相同。
  - 在计算机上编辑图片等文件时可能会自动加上时间信息等内容，导致最后保存的文件内容看起来一样，实际上二进制数据并不一样，因此 Hash 值不同。
- 如果两个数据的内容不同（即使只有一个 bit 的差异），则它们的 Hash 值几乎总是不同。
  - 如果相同，则称为发生碰撞。哈希算法的碰撞率越低越好。
  - MD5 只生成 128 位的散列值，因此碰撞率比 SHA256 高。
- 如果只知道一个数据的 Hash 值，则一定不能据此反推出原数据的内容。
  - 因为理论上生成同一个 Hash 值的原数据可能有无数种。想反推出原数据，除非哈希算法存在容易被反推的缺陷，或者建立一个庞大的数据库，存储常见的一些数据的哈希值。
- 哈希算法的用途：
  - 用于数据的一致性检验。比如生成某段数据的 MD5 值，如果与之前的 MD5 值不同，就说明该数据被篡改了。
  - 用于加密用户的密码。比如 Web 服务器不储存用户的明文密码，而是储存密码的 MD5 值，这样既可以检验用户输入的密码是否正确，还能防止 Web 服务器泄露用户的明文密码。

## 密码的加密

Web 服务器可以将用户的密码的哈希值存储在数据库中，只要用户下次输入的密码的哈希值相同，就判断密码正确。
- 一般来说，即使密码的哈希值被泄露，Hacker 也不会知道对应的明文密码。
- 不过，Hacker 可能通过以下方法，暴力破解出 Hash 值对应的明文密码：
  - 穷举法
  - 字典法：记下人们常用的密码及其对应的 Hash 值。当目标 Hash 值与字典中某项匹配时，就可以知道对应的明文密码。
  - 彩虹表：确定哈希算法的函数 H()，再拟定一个将哈希值 h 转换成另一个字符串 p 的函数 R()。然后选择一个字符串 p1 作为起点，逐个算出 h1=H(p1)、p2=R(h1)、h2=H(p2)、……，这样就得到了一条哈希链，记下其中的所有 p 。选取多个 p1 ，就可以算出多条哈希链，得到一个彩虹表。想破解某个哈希值 s 时，就计算 R(s)，到彩虹表中寻找是否有与之相同的 p 值。如果 pn 的值与 R(s)相同，则 s 对应的明文密码就是 pn-1 。
    - 使用彩虹表时比字典法少了一半的存储空间，又比穷举法快。
- 针对上述破解方法，Web 服务器可采用以下措施提高密码的安全性：
  - 选用 Hash 值更长、加密更慢的 Hash 算法，增加暴力破解的试错成本。
  - 每次加密密码时加上一个随机的、无法预测的“盐”，这样即使 Hacker 知道了服务器采用的 Hash 算法，也不能事先准备一个破解字典。
    - 服务器应该将每个用户的密码与盐值一起保存到数据库中。
- 判断两个 Hash 值是否相同时，无论结果是 True 还是 False 甚至出错，都应该控制在相同的处理时长。
  - 如果使用一般的字符串比较方法（从左到右逐位比较，遇到某一位的字符不同时就返回 False），就可能被 Hacker 根据处理时长的微小差异逐位试出 Hash 值的每一位应该是什么值。
  - 使用异或运算就可以控制在相同的处理时长。比如：a ^ b == 0

## ♢ Hashlib

：Python 的标准库，提供了 MD5、SHA1、SHA256、SHA512 等常见哈希算法的函数。

- 例：
    ```python
    >>> import Hashlib
    >>> h = Hashlib.sha256()          # 创建一个 Hash 对象
    >>> h.update("Hello".encode())    # 输入要 Hash 的内容（必须转换成 bytes 类型）
    >>> h.update("World".encode())    # 可以累加
    >>> h.digest()                    # 生成 Hash 值（也是 bytes 类型）
    b'\x87.NP\xce\x99\x90\xd8\xb0A3\x0cG\xc9\xdd\xd1\x1b\xeckP:\xe98j\x99\xda\x85\x84\xe9\xbb\x12\xc4'
    >>> Hashlib.sha256("HelloWorld".encode()).digest()      # 可简化成一步
    b'\x87.NP\xce\x99\x90\xd8\xb0A3\x0cG\xc9\xdd\xd1\x1b\xeckP:\xe98j\x99\xda\x85\x84\xe9\xbb\x12\xc4'
    ```
- 加盐的方法：
    ```python
    import os
    salt = os.urandom(10)      # 生成指定字节数的随机 bytes 对象
    password = '123456'.encode()
    Hash_bytes = salt + password
    result = Hashlib.sha256(Hash_bytes).digest()
    ```
    - 用 Python 的 random 模块生成的随机数是不安全的，此处应该用 os.urandom()函数生成随机数。
 
## ♢ hmac

：Python 的标准库，提供了 hmac 算法的加密函数。
- MAC 算法是使用密钥的 Hash 算法。
- hmac 算法使用一个 key 和一种 Hash 算法对消息进行加密，比单纯的 Hash 加盐更安全。
- 例：
    ```python
    >>> import hmac
    >>> key = os.urandom(10)
    >>> msg = '123456'.encode()
    >>> hmac.new(key, msg, 'sha256').digest()
    b'\xa5\x06^\xeb\xf11B\xad\x9c\x88\x88\x80\xacz\xcb\xd4K\xe2\x01\xd8\x95DD\xa8{\\:t\x19\x87\xd
    b\xfa'
    >>> hmac.compare_digest(b'123', b'123')    # 比较两个 Hash 值是否相同
    True
    ```
