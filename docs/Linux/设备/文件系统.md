# 文件系统

将一个磁盘接入Linux主机之后，首先要进行磁盘分区（不分区的话只有一个区），再将它格式化成某种文件系统，最后挂载到某个目录，才能被用户读写。

## 磁盘分区

- 进行磁盘分区的好处：
  - 磁盘分区之间相互独立，可采用不同的文件系统。
  - 磁盘分区之间相互隔离，一个分区发生故障时不会影响到其它分区。
- 磁盘的读写速度受到读写方式的影响，比如顺序读还是随机读、是否采用缓存。
- 磁盘分区要挂载到某个目录之后才能被用户读写。
  - 例如：当系统插入CD之后会生成磁盘分区 /dev/cdrom ，要执行命令 mount /dev/cdrom /media/cdrom 将它挂载。
- 被挂载的目录称为挂载点。
  - 挂载后，原本位于挂载点目录下的文件会不可见。
  - Linux系统启动时，首先挂载的是根目录，然后才能挂载其它目录。

## 文件系统

- block：文件系统读写数据时的最小单位。
  - 即使一次只存储1byte数据，也要占用1个block。
  - etx3文件系统的block size为4096 bytes。
  - 不同磁盘分区的文件系统可以设置不同的block size。
  - 碎片整理：将磁盘中存储同一个文件的block整理到一起，提高读写速度。
- inode：block的索引节点。
  - 每个文件都有一个唯一的inode序号，指向它在磁盘中的存储位置。
  - 例如：当系统要读取某个文件时，得知该文件的inode序号为4，于是去磁盘的inode table区块中查询，获取到inode 4对应的文件的基本属性（包括访问权限、修改时间等）、存储在哪些block。
  - 当指向一个inode的所有文件都被删除时，系统就可以释放其占用的block。
  - 当文件系统被创建之后，block和inode就固定下来了，数量、位置都不能改变。
- block group：磁盘中的所有block被分成几组。
- super block：保存整个文件系统的信息，包括block、inode的数量、使用情况等。
  - super block一般位于第一个block group中。

## 分类

- 存储在磁盘中的文件系统：
  - etx2 ：扩展文件系统（extended file system）的第二代，于1993年开始被Linux内核使用。
  - etx3 ：兼容etx2。能记录日志，在非正常关机后能根据日志快速恢复关机时没有保存的数据，而不必扫描整个硬盘。
  - etx4 ：兼容etx3。支持更大的文件系统和文件，支持无限数量的子目录。RHEL6的默认文件系统。
  - xfs ：一种优秀的日志文件系统。RHEL7的默认文件系统。
  - btrfs
  - FAT ：1977年由比尔盖茨发明。目前最常见的一种FAT系统是FAT32，它限制了单个文件最大为4G。
  - NTFS ：1993年由微软公司发明，适用于Windows2000及以后的Windows版本。单个文件没有大小限制。
- 存储在flash中的文件系统：（常用于嵌入式系统）
  - jffs2
  - yaffs
  - cramfs ：一种只读的压缩文件系统。文件被压缩后节约了大量存储空间，要载入RAM时才解压缩。
  - romfs
- 存储在RAM中的文件系统：（用一部分RAM来存储数据，读写速度快）
  - ramdisk
  - ramfs/tmpfs
  - proc ：挂载在/proc目录下。
  - sysfs ：挂载在/sys目录下。
  - devfs ：设备文件系统，将已注册的设备放到/dev目录下管理。
    - Linux kernel 2.6 版本开始使用一个用户态进程 udev 代替 devfs 进行设备管理，udev进程在运行时以 /sys 目录下的设备信息文件为依据。
- 存储在网络中的文件系统。
  - nfs：网络文件系统（Network File System），可以让不同主机通过网络共享文件。

## 相关命令

```shell
$ df        # 显示系统所有文件系统的信息
    [file]  # 显示指定文件所属的文件系统的信息
    -h      # 显示让人易读的单位（默认单位为 kBytes）
    -i      # 增加显示inode的数量
    -a      # 显示所有文件系统（包括proc、swap）
    -T      # 增加显示文件系统的类型
```

```shell
$ fdisk
        -l          # 显示系统所有的磁盘（disk）和磁盘分区
        <磁盘名>    # 打开一个终端，对指定磁盘进行配置
```
- 进入fdisk终端之后，可以输入以下命令：
    ```shell
    p      # 显示已有的磁盘分区
    n      # 创建一个分区
    p      # 接着输入p会创建主分区，输入e会创建扩展分区
    2      # 然后设置分区编号
    Enter  # 设置起始扇区（按回车会使用默认值）
    +20G   # 设置结束扇区（可指定扇区大小）
    d      # 删除一个分区
    w      # 将设置内容保存
    ```

```shell
$ mkfs
      -t <文件系统名> <磁盘分区名>  # 将一个磁盘分区格式化成某种文件系统
```
- 例：
    ```shell
    mkfs -t ext4 /dev/sdb1
    ```

```shell
$ mount               # 显示已挂载的所有目录
        <磁盘分区名> <挂载点>  # 将一个磁盘分区挂载到指定目录
        -t ext4       # 挂载后格式化为指定文件系统（不指定的话会自动选择一种文件系统）
        -r            # 挂载为只读模式
        -L "sdb6"     # 添加卷标
```
- 例：
    ```
    mount /dev/hdc1 /mnt/hdc1
    ```
- 一般先用fdisk -l查看磁盘分区的名字，再检查挂载点是否存在，不存在的话就用mkdir -p创建。然后才用mount挂载。
- 用mount挂载的目录在系统重启后不会再挂载。编辑 /etc/fstab 文件可以设置系统开机时自动挂载的目录：
    ```
    /dev/vda1    /    ext3    defaults    1    1
    ```

```shell
$ umount <磁盘分区名或挂载点>   # 卸载磁盘分区
        -f                     # 强制卸载
```

使用 autofs 服务可以在用户访问一个尚未挂载的磁盘分区时自动挂载它，降低空闲时的系统负载。

## 交换分区

```shell
$ mkswap /dev/sdb1     # 将一个磁盘分区格式化成swap分区
```
  - 编辑 /etc/fstab 文件可以设置系统开机时自动挂载的swap目录：
    ```
    /dev/sdb1    swap    swap    defaults     0    0
    ```

```shell
$ swapon /dev/sdb1     # 启用swap分区
```

```shell
$ swapoff /dev/sdb1    # 停用swap分区
```

## 数据备份

按实现方式分类:
- 物理备份：将存储文件的磁盘分区直接复制到备份介质上。
  - 这样恢复文件的速度慢，因为文件的各逻辑部分很可能分散在磁盘的不同位置，需要花时间查找和整理。
- 逻辑备份：从磁盘上读取文件然后复制到备份介质的连续存储空间上。
  - 这样备份速度慢，但是恢复速度快。

按是否停止服务分类:
- 在线备份：又称为热备份，在备份的同时保持对用户提供服务，允许用户改变服务器的数据。
- 离线备份：又称为冷备份。

按备份策略分类:
- 完全备份：将所有文件都备份。
  - 这种备份策略最简单，恢复速度最快，但是备份速度最慢。
- 增量备份：只备份上一次备份操作后的改动记录，恢复文件时需要按顺序使用每一次增量备份，任何一次增量备份都不能出问题。
  - 这样备份速度最快，每次占用的磁盘空间也小，但是可靠性最低，恢复速度最慢。
- 差异备份：将上一次完全备份后的改动记录都备份下来，这样恢复文件时只需要使用一个完全备份和一个差异备份。
  - 效果介于完全备份与增量备份之间。
