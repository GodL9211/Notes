# 文件系统

将一个磁盘接入 Linux 主机之后，首先要进行磁盘分区（不分区的话只有一个区），再将它格式化成某种文件系统，最后挂载到某个目录，才能被用户读写。

## 磁盘分区

- 划分磁盘分区的好处：
  - 磁盘分区之间相互独立，可采用不同的文件系统。
  - 磁盘分区之间相互隔离，一个分区发生故障时不会影响到其它分区。
- 磁盘的读写速度受到读写方式的影响，比如顺序读还是随机读、是否采用缓存。
- 磁盘分区要挂载到某个目录之后才能被用户读写。
  - 例如：当系统插入 CD 之后会生成磁盘分区 `/dev/cdrom` ，要执行 `mount /dev/cdrom /media/cdrom` 将它挂载。
- 被挂载的目录称为挂载点。
- 挂载后，原本位于挂载点目录下的文件会不可见，相当于被一层新目录挡住了。

## 文件系统

- block ：文件系统读写数据时的最小单位。
  - 即使一个文件只包含 1 byte 数据，存储时也要占用 1 个 block 。
  - etx3 文件系统的 block size 为 4096 Bytes 。
  - 不同磁盘分区的文件系统可以设置不同的 block size 。
  - 碎片整理：将磁盘中存储同一个文件的 block 整理到一起，提高读写速度。
- inode ：block 的索引节点。
  - 每个文件都有一个唯一的 inode 序号，指向它在磁盘中的存储位置。
  - 当文件系统被创建之后，block 和 inode 就固定下来了，数量、位置都不能改变。
  - 当指向一个 inode 的所有文件都被删除时，系统就会释放该 inode 及其 block ，供新写入磁盘的文件使用。
  - 例：
    - 当系统要读取某个文件时，得知该文件的 inode 序号为 4 ，于是去磁盘的 inode table 区块中查询，获取到 inode 4 对应的文件的基本属性（包括访问权限、修改时间等）、存储在哪些 block 。
    - 如果在同一个文件系统内用 mv 移动文件，则新的文件依然使用之前的 inode ，不会在磁盘中重新拷贝一份数据，因此几乎不消耗时间。
    - 用 `echo Hello > f1` 的方式修改文件时， inode 不会变化。用 `vim f1` 的方式修改文件时，默认会先创建一个备份文件进行修改，然后替换原文件，因此 inode 会变化。
- block group ：磁盘中的所有 block 被分成几组。
- super block ：保存整个文件系统的信息，包括 block、inode 的数量、使用情况等。
  - super block 一般位于第一个 block group 中。

## 分类

- 存储在磁盘中的文件系统：
  - etx2 ：扩展文件系统（extended file system）的第二代，于 1993 年开始被 Linux 内核使用。
  - etx3 ：兼容 etx2 。能记录日志，在非正常关机后能根据日志快速恢复关机时没有保存的数据，而不必扫描整个硬盘。
  - etx4 ：兼容 etx3 。支持更大的文件系统和文件，支持无限数量的子目录。是 RHEL6 的默认文件系统。
  - xfs ：一种优秀的日志文件系统。是 RHEL7 的默认文件系统。
  - btrfs
  - FAT ：1977 年由比尔盖茨发明。目前最常见的一种 FAT 系统是 FAT32 ，它限制了单个文件最大为 4G 。
  - NTFS ：1993 年由微软公司发明，适用于 Windows2000 及以后的 Windows 版本。单个文件没有大小限制。
- 存储在 flash 中的文件系统：（常用于嵌入式系统）
  - jffs2
  - yaffs
  - cramfs ：一种只读的压缩文件系统。文件被压缩后节约了大量存储空间，要载入 RAM 时才解压缩。
  - romfs
- 存储在 RAM 中的文件系统：（读写速度快）
  - rootfs ：根目录系统。
    - 它的挂载点是它自己的 / 目录。
    - Linux 系统启动时，首先在内存中创建 rootfs ，用于给其它文件系统提供挂载点。比如将一个 etx4 文件系统挂载到 rootfs 的 / 目录，作为磁盘，使得 rootfs 对用户不可见。
  - ramdisk
  - ramfs/tmpfs 
  - proc ：挂载到 /proc 目录。
  - sysfs ：挂载到 /sys 目录。
  - devfs ：设备文件系统，将已注册的设备放到/dev 目录下管理。
    - Linux kernel 2.6 版本开始使用一个用户态进程 udev 代替 devfs 进行设备管理，udev 进程在运行时以 /sys 目录下的设备信息文件为依据。
- 存储在网络中的文件系统。
  - nfs ：网络文件系统（Network File System），可以让不同主机通过网络共享文件。

## 相关命令

### df

```sh
$ df        # 显示系统所有文件系统的信息
    [file]  # 显示指定文件所属的文件系统的信息
    -h      # 以人类容易阅读的单位显示文件大小（默认单位为 kBytes）
    -i      # 显示 inode 的数量、使用率
    -a      # 显示所有文件系统（包括 proc、swap）
    -T      # 增加显示文件系统的类型
```
### fdisk

```sh
$ fdisk
        -l          # 显示系统所有的磁盘（disk）和磁盘分区
        <磁盘名>    # 打开一个终端，对指定磁盘进行配置
```
- 进入 fdisk 终端之后，可以输入以下命令：
  ```sh
  p      # 显示已有的磁盘分区
  n      # 创建一个分区
  p      # 接着输入 p 会创建主分区，输入 e 会创建扩展分区
  2      # 然后设置分区编号
  Enter  # 设置起始扇区（按回车会使用默认值）
  +20G   # 设置结束扇区（可指定扇区大小）
  d      # 删除一个分区
  w      # 将设置内容保存
  ```

### mkfd

```sh
$ mkfs
      -t <文件系统名> <磁盘分区名>  # 将一个磁盘分区格式化成某种文件系统
```
- 例：
  ```sh
  mkfs -t ext4 /dev/sdb1
  ```

### mount

```sh
$ mount                       # 显示已挂载的所有目录
        <磁盘分区名> <挂载点>  # 将一个磁盘分区挂载到指定目录
        -t ext4               # 挂载后格式化为指定文件系统（不指定的话会自动选择一种文件系统）
        -r                    # 挂载为只读模式
        -L "sdb6"             # 添加卷标
```
- 例：
  ```
  mount /dev/hdc1 /mnt/hdc1
  ```
- 一般先用 fdisk -l 查看磁盘分区的名字，再检查挂载点是否存在，不存在的话就用 mkdir -p 创建。然后才用 mount 挂载。
- 用 mount 挂载的目录在系统重启后不会再挂载，编辑 `/etc/fstab` 文件可以设置系统开机时自动挂载的目录：
  ```sh
  /dev/vda1    /    ext3    defaults    1    1
  ```

### umount

```sh
$ umount <磁盘分区名或挂载点>   # 卸载磁盘分区
        -f                    # 强制卸载
```

### autofs

使用 autofs 服务可以在用户访问一个尚未挂载的磁盘分区时自动挂载它，降低空闲时的系统负载。

## Swap 分区

：交换分区，一个可以临时充当内存的特殊磁盘分区。
- 作用相当于 Windows 系统的磁盘虚拟内存。
  - 当 page 数不足时，MMU 会将 page 中某些暂时不用处理的数据暂时移到 Swap 分区中（称为 swap out）。
  - Windows 中即使没用完物理内存也可能使用虚拟内存，而 Linux 中只有用完了物理内存才会使用 swap 分区。
- 分配 Swap 分区有利于维持系统的稳定，但是 Swap 交换会让 CPU 从磁盘读写数据，比从物理内存读写数据慢得多，还会增加磁盘 IO 压力。
  - 因此，如果系统内存不是太少，可以禁用 swap 。
- 可以将一个磁盘分区定义成 Swap 分区，也可以使用一个文件创建 Swap 分区。

### mkswap

```sh
$ mkswap [device]     # 将一个磁盘分区或文件格式化成 swap 分区类型
```
- 例：
  ```sh
  [root@CentOS ~]# dd if=/dev/zero of=/swapfile count=1024 bs=1M
  1024+0 records in
  1024+0 records out
  1073741824 bytes (1.1 GB) copied, 2.73547 s, 393 MB/s
  [root@CentOS ~]# mkswap /swapfile
  Setting up swapspace version 1, size = 1048572 KiB
  no label, UUID=32de6480-099b-4ff1-b4f2-ea44b75ae430
  [root@CentOS ~]# chmod 600 /swapfile
  [root@CentOS ~]# swapon /swapfile
  ```
- 编辑 `/etc/fstab` 文件可以设置系统开机时自动挂载的 swap 分区：
  ```sh
  /swapfile    swap    swap    defaults     0    0
  ```

### swapon

```sh
$ swapon
          /swapfile   # 启用指定的 swap 分区
          -a          # 启用 /etc/fstab 中定义的所有 swap 分区
          -s          # 显示已启用的所有 swap 分区
```

### swapoff

```sh
$ swapoff
          /swapfile   # 停用指定的 swap 分区
          -a          # 停用 /etc/fstab 中定义的所有 swap 分区
```

## 数据备份

按实现方式分类:
- 物理备份：将存储文件的磁盘分区直接复制到备份介质上。
  - 这样恢复文件的速度慢，因为文件的各逻辑部分很可能分散在磁盘的不同位置，需要花时间查找和整理。
- 逻辑备份：从磁盘上读取文件然后复制到备份介质的连续存储空间上。
  - 这样备份速度慢，但是恢复速度快。

按是否停止服务分类:
- 在线备份：又称为热备份，在备份的同时保持对用户提供服务，允许用户改变服务器的数据。
- 离线备份：又称为冷备份。

按备份策略分类:
- 完全备份：将所有文件都备份。
  - 这种备份策略最简单，恢复速度最快，但是备份速度最慢。
- 增量备份：只备份上一次备份操作后的改动记录，恢复文件时需要按顺序使用每一次增量备份，任何一次增量备份都不能出问题。
  - 这样备份速度最快，每次占用的磁盘空间也小，但是可靠性最低，恢复速度最慢。
- 差异备份：将上一次完全备份后的改动记录都备份下来，这样恢复文件时只需要使用一个完全备份和一个差异备份。
  - 效果介于完全备份与增量备份之间。
