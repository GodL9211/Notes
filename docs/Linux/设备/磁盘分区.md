# 磁盘分区

## 磁盘分区

- 给 Linux 主机添加磁盘的步骤：
  1. 接入一个硬盘设备。
  2. 硬盘中默认只有一个磁盘分区，可以用 fdisk 命令创建多个磁盘分区。
  3. 用 mkfd 命令将磁盘分区格式化成某种文件系统。
  4. 用 mount 命令将磁盘分区挂载到目录树中某个目录，供用户读写。
- 划分磁盘分区的好处：
  - 磁盘分区之间相互独立，可采用不同的文件系统。
  - 磁盘分区之间相互隔离，一个分区发生故障时不会影响到其它分区。
- 磁盘分区要挂载到目录树中某个目录，才能被用户读写。
  - 被挂载的目录称为挂载点。
  - 挂载后，原本位于挂载点目录下的文件会对用户不可见，相当于被新的一层目录覆盖了。
  - 例如：当系统插入 CD 之后会自动生成磁盘分区 `/dev/cdrom` ，要执行 `mount /dev/cdrom /media/cdrom` 将它挂载，才能读写。

### fdisk

```sh
$ fdisk
        -l          # 显示系统所有的磁盘（disk）和磁盘分区
        <磁盘名>    # 打开一个终端，对指定磁盘进行配置
```
- 进入 fdisk 终端之后，可以输入以下命令：
  ```sh
  p      # 显示已有的磁盘分区
  n      # 创建一个分区
  p      # 接着输入 p 会创建主分区，输入 e 会创建扩展分区
  2      # 然后设置分区编号
  Enter  # 设置起始扇区（按回车会使用默认值）
  +20G   # 设置结束扇区（可指定扇区大小）
  d      # 删除一个分区
  w      # 将设置内容保存
  ```

### mkfd

```sh
$ mkfs
      -t <文件系统> <磁盘分区>  # 将一个磁盘分区格式化成某种文件系统
```
- 例：
  ```sh
  mkfs -t ext4 /dev/vdb
  ```
  - 如果该磁盘分区已存在文件系统，则会报错：`/dev/vdb appears to contain an existing filesystem`
  - 如果该磁盘分区已被挂载，则会报错：`/dev/vdb contains a mounted filesystem`

### mount

```sh
$ mount                      # 显示已挂载的所有目录
        <文件系统> <挂载点>   # 将一个文件系统挂载到指定目录
            -t ext4          # 挂载后格式化为指定文件系统（不指定的话会自动选择一种文件系统）
            -r               # 挂载为只读模式
            -L "sdb6"        # 添加卷标
        -a                   # 挂载 /etc/fstab 中定义的所有文件系统
```
- 例：
  ```sh
  mount /dev/vdb  /data
  ```
  - 如果挂载点不存在，则会报错：`mount point /data does not exist`
- 用 mount 命令挂载的目录在系统重启后不会再挂载，编辑 `/etc/fstab` 文件可以设置系统开机时自动挂载的目录，如下：
  ```sh
  /dev/vdb    /data    xfs    defaults    1    1
  ```

### umount

```sh
$ umount
        <文件系统或挂载点>   # 卸载指定的文件系统
            -f              # 强制卸载
        -a                  # 卸载所有文件系统
```

### autofs

使用 autofs 服务可以在用户访问一个尚未挂载的文件系统时自动挂载它，降低空闲时的系统负载。

## Swap 分区

：交换分区，一个可以临时充当内存的特殊磁盘分区。
- 作用相当于 Windows 系统的磁盘虚拟内存。
  - 当 page 数不足时，MMU 会将 page 中某些暂时不用处理的数据暂时移到 Swap 分区中（称为 swap out）。
  - Windows 中即使没用完物理内存也可能使用虚拟内存，而 Linux 中只有用完了物理内存才会使用 swap 分区。
- 分配 Swap 分区有利于维持系统的稳定，但是 Swap 交换会让 CPU 从磁盘读写数据，比从物理内存读写数据慢得多，还会增加磁盘 IO 压力。
  - 因此，如果系统内存不是太少，可以禁用 swap 。
- 可以将一个磁盘分区定义成 Swap 分区，也可以使用一个文件创建 Swap 分区。

### mkswap

```sh
$ mkswap
          [device]     # 将一个磁盘分区或文件格式化成 swap 分区类型
```
- 例：
  ```sh
  [root@CentOS ~]# dd if=/dev/zero of=/swapfile count=1024 bs=1M
  1024+0 records in
  1024+0 records out
  1073741824 bytes (1.1 GB) copied, 2.73547 s, 393 MB/s
  [root@CentOS ~]# mkswap /swapfile
  Setting up swapspace version 1, size = 1048572 KiB
  no label, UUID=32de6480-099b-4ff1-b4f2-ea44b75ae430
  [root@CentOS ~]# chmod 600 /swapfile
  [root@CentOS ~]# swapon /swapfile
  ```
- 编辑 `/etc/fstab` 文件可以设置系统开机时自动挂载的 swap 分区：
  ```sh
  /swapfile    swap    swap    defaults     0    0
  ```

### swapon

```sh
$ swapon
          [device]    # 启用指定的 swap 分区
          -a          # 启用 /etc/fstab 中定义的所有 swap 分区
          -s          # 显示已启用的所有 swap 分区
```

### swapoff

```sh
$ swapoff
          [device]    # 停用指定的 swap 分区
          -a          # 停用所有 swap 分区
```

## 文件系统

### block

：文件系统读写数据时的最小单位。
- 即使一个文件只包含 1 byte 数据，存储时也要占用 1 个 block 。
- 不同磁盘分区的文件系统可以设置不同的 block size 。
  - 例如，etx3 文件系统的 block size 默认为 4096 Bytes 。
- 碎片整理：将磁盘中存储同一个文件的 block 整理到一起，提高读写速度。
- block group ：磁盘中的所有 block 被分成几组。
- super block ：保存整个文件系统的信息，包括 block、inode 的数量、使用情况等。
  - 一般位于第一个 block group 中。

### inode

：索引节点（index node），用于记录一个文件在磁盘中的信息。
- 新建一个文件保存到磁盘时，系统会给它分配一些 block 用于存储，再分配一个 inode 用于记录文件信息。
- 每个 inode 有一个数字编号作为唯一标识。
  - inode 里会记录文件的元数据。主要是通过 stat 命令查看到的那些信息，比如文件类型、访问权限、指向该 inode 的硬链接数。
  - inode 里会记录文件内容存储在磁盘的哪些 block 中。
  - inode 里并不会记录文件名，文件名记录在目录文件中。
    - 因此移动、重命名文件时，不会改变文件本身（最后修改时间不变），而会改变所属的目录文件。
- 每个文件系统在创建时，会划分 block 的位置、inode 的总数，不能改变。
  - 每个文件系统会在磁盘中存储一张索引表（inode table），记录所有已使用的 inode 的内容。
  - 当指向一个 inode 的所有文件都被删除时，系统就会认为该 inode 及其 block 不再使用，可以释放，供新创建的文件使用。
- 例：
  - 假设 Linux 系统要读取路径为 path 的某个文件的内容，需要先查询到该文件路径对应的 inode 编号为 xxx 。然后到磁盘的 inode table 中，找到该 inode 的内容，知道该文件存储在哪些 block 。最后读取这些 block 。
  - 不能直接根据一个 inode 反查出对应的文件路径，只能遍历大量文件才能找出来。
  - 如果在同一个文件系统内用 `mv f1 f2` 的方式移动文件，则新的文件依然使用之前的 inode ，不会在磁盘中重新拷贝一份数据，因此几乎不消耗时间。
  - 在同一个文件系统内用 `echo Hello > f1` 的方式修改文件时， inode 编号不会变化。用 `vim f1` 的方式修改文件时，默认会先创建一个备份文件进行修改，然后替换原文件，因此 inode 编号会变化。

- 例：在 Python 中编辑文件
  ```py
  >>> f = open('f1', 'w+')  # 打开文件，这会自动分配一个文件描述符，并根据文件路径查询到 inode ，读取文件的内容
  >>> f.write('Hello\n')    # 给文件写入内容，即使覆盖原有内容，即使写入很长的内容，也不会改变文件的 inode
  6
  >>> f.name                # 查看文件名
  'f1'
  >>> f.close()             # 关闭文件，即关闭文件描述符
  ```
  - 当 Python 编辑文件时，可以另开一个终端，执行 `mv f1 f2` 重命名文件。在 Windows 上则不允许修改已打开的文件。
    - 此时 Python 写入文件的内容会根据原 inode 写入磁盘，关联到 f2 。
    - 不过在 Python 中执行 `f.name` ，依然会返回最初的文件名 f1 ，不会根据 inode 反查出当前的文件名。

### 分类

- 存储在磁盘中的文件系统如下：
  - etx2 ：扩展文件系统（extended file system）的第二代，于 1993 年开始被 Linux 内核使用。
  - etx3 ：兼容 etx2 。能记录日志，在非正常关机后能根据日志快速恢复关机时没有保存的数据，而不必扫描整个硬盘。
  - etx4 ：兼容 etx3 。支持更大的文件系统和文件，支持无限数量的子目录。是 RHEL6 的默认文件系统。
  - xfs ：一种优秀的日志文件系统。是 RHEL7 的默认文件系统。
  - btrfs
  - FAT ：1977 年由比尔盖茨发明。目前最常见的一种 FAT 系统是 FAT32 ，它限制了单个文件最大为 4G 。
  - NTFS ：1993 年由微软公司发明，适用于 Windows2000 及以后的 Windows 版本。单个文件没有大小限制。
- 存储在 flash 中的文件系统如下，常用于嵌入式系统：
  - jffs2
  - yaffs
  - cramfs ：一种只读的压缩文件系统。文件被压缩后节约了大量存储空间，要载入 RAM 时才解压缩。
  - romfs
- 存储在 RAM 中的文件系统如下，读写速度很快：
  - rootfs ：根目录系统。
    - 它的挂载点是它自己的 / 目录。
    - Linux 系统启动时，内核会创建一个只读（read-only）模式的 rootfs 。启动完成之后，可以将 rootfs 切换成读写（read-write）模式，或者在它上面挂载其它文件系统。
      - 比如将一个 etx4 文件系统挂载到 rootfs 的 / 目录，使得 rootfs 对用户不可见。
  - ramdisk
  - ramfs/tmpfs
  - proc ：挂载到 /proc 目录。
  - sysfs ：挂载到 /sys 目录。
  - devfs ：设备文件系统，用于将已注册的设备放到/dev 目录下管理。
    - Linux kernel 2.6 版本开始使用一个用户态进程 udev 代替 devfs 进行设备管理，udev 进程在运行时以 /sys 目录下的设备信息文件为依据。
- 存储在网络中的文件系统如下：
  - nfs ：网络文件系统（Network File System），可以让不同主机通过网络共享文件。

### df

```sh
$ df        # 显示系统所有文件系统的信息
    [file]  # 显示指定文件所属的文件系统的信息
    -h      # 以人类容易阅读的单位显示文件大小（默认单位为 kBytes）
    -i      # 显示 inode 的数量、使用率
    -a      # 显示所有文件系统（包括 proc、swap）
    -T      # 增加显示文件系统的类型
```

## 数据备份

按实现方式分类:
- 物理备份：将存储文件的磁盘分区直接拷贝到备份介质上。
  - 这样恢复文件的速度慢，因为文件的各逻辑部分很可能分散在磁盘的不同位置，需要花时间查找和整理。
- 逻辑备份：从磁盘上读取文件然后复制到备份介质的连续存储空间上。
  - 这样备份速度慢，但是恢复速度快。

按是否停止服务分类:
- 在线备份：又称为热备份，在备份的同时保持对用户提供服务，允许用户改变服务器的数据。
- 离线备份：又称为冷备份。

按备份策略分类:
- 完全备份：将所有文件都备份。
  - 这种备份策略最简单，恢复速度最快，但是备份速度最慢。
- 增量备份：只备份上一次备份操作后的改动记录，恢复文件时需要按顺序使用每一次增量备份，任何一次增量备份都不能出问题。
  - 这样备份速度最快，每次占用的磁盘空间也小，但是可靠性最低，恢复速度最慢。
- 差异备份：将上一次完全备份后的改动记录都备份下来，这样恢复文件时只需要使用一个完全备份和一个差异备份。
  - 效果介于完全备份与增量备份之间。
