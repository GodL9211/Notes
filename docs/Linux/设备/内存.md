# 内存

：Memory ，又称为内部存储器、主存储器、物理内存。
- 内存能被 CPU 直接读写，用于暂时保存 CPU 处理的数据。
- 内存一般比外存的读写速度快，但是存储容量小。
- 一个内存条包含几个内存芯片以及外围电路，每个内存芯片中都集成了大量的内存颗粒。

## 存储技术

### ROM

常见技术：

- 只读存储器（Read Only Memory，ROM）
  - 只能读取数据，不能写入数据。
  - 断电后数据不会丢失，因此能持久保存数据。

- 可编程 ROM（Programmable ROM，PROM）
  - 出厂时，存储的每个 bit 都为 1 ，用户可以擦除为 0 ，从而写入数据，但只能擦除一次。

- 可擦除可编程 ROM（Erasable Programmable ROM，EPROM）
  - 通过照射紫外线来擦除，可以多次擦除。

- 电可擦除可编程 ROM（EEPROM）
  - 可以用电信号多次擦除，但是以 Byte 为单位擦除，效率低。

- 闪存（FLash Memory）
  - 属于改进型的 EEPROM ，基于浮栅晶体管存储电荷。
  - 主要分类：
    - NOR
      - ：基于与或门（NOT-OR）。
      - 容量小，一般为几十 MB 。擦写速度慢，支持随机访问。
      - 常用于 BIOS 等存储数据少的嵌入式设备。
    - NAND
      - ：基于与非门（NOT-AND）。
      - 容量大。擦写速度快，以 Block 为单位访问。
      - 常用于 U 盘、SSD 设备。
  - 传统的嵌入式设备（比如 BIOS ）一般采用 EPROM 存储数据，目前改用 Flash 。

### RAM

：随机存储器（Random Access Memory），泛指可以在任意位置读、写数据的存储器。

常见技术：

- 动态 RAM（DRAM）
  - ：基于电容存储电荷，用电容的充、放电之后的电压高低表示二进制的 1、0 。不过电容的电荷会缓慢耗散，需要定期刷新电容。
  - 结构简单，容易做到高密度、大存储容量。
  - 常用于一般计算机的内存。

- 静态 RAM（SRAM）
  - ：用两个 CMOS 晶体管组成非门，在保持供电的情况下会保持电信号。
  - SRAM 比 DRAM 的成本更高，但读写速度快很多。
  - 常用于 CPU Cache 。

- 非易失性 RAM（Non-Volatile ，NVRAM）
  - ：基于浮栅晶体管存储电荷，即使断电也可以持久保持电信号。
  - 非易失性是指断电后数据不会丢失，而 DRAM、SRAM 都是易失性，需要保持供电。

## 内存管理

### Page

- 内核通过 buddy system 以 page 为单位管理内存，每个 page 默认为 4 KB 。
- 如果程序申请几个字节的内存时，内核也分配一个 page ，则会产生未被使用的内存空间，称为内部碎片（internal fragmentation）。
- 为了减少内部碎片，Linux 采用了 Slab 分配器：为一些经常分配的、占内存小的对象专门划分内存空间，管理单位为 Bytes 。
  - 例如：进程描述符需要经常创建，因此事先为该类对象划分一组内存空间，称为一个 Slab ，存储时占用一个或多个 Page 。
  - 每种对象需要定义一个结构体 `struct kmem_cache` ，用于创建 Slab 、划分内存空间。
  - Slab 分为两种：
    - Unreclaim ：不可回收的。
    - Reclaimable ：可回收的。
- Huge Page ：指大于 4 KB 的内存页，比如 2MB、1GB 。
  - 优点：
    - 减少进程存储数据时使用的 Page 数，从而减少查询 Page Table 的次数和耗时。
    - 支持锁定 Page ，禁止交换到 Swap 分区。

### MMU

：Linux 内核中的内存管理单元（Memory Management Unit）。
- 当物理内存的 page 数不足时，MMU 可能采取三种措施：
  - 回收最近不用的 page 。
  - 将不常用的内存数据从 page 移到 swap 分区。
  - 通过 OOM 杀死某些占用大量内存的进程。
- MMU 为每个进程都维护了一张页表（Page Table），将进程的虚拟内存空间中要使用的内容，映射到物理内存的一些 page 中。
  - 这些 page 的集合称为该进程的 working set 。
  - 当进程申请分配一块内存之后，内核并不会立即分配相应的物理内存。而是等进程首次访问该内存时，CPU 会发现该内存不存在而报出缺页异常，MMU 才分配物理内存。
    - 进程申请的所有内存称为虚拟内存，其中被实际使用的部分称为常驻内存。
  - 当进程想读写某个内存空间时，CPU 会先获取其虚拟内存地址，然后到 Page Table 中找到对应的物理内存地址，访问其中的数据。
  - 如果 CPU 在物理内存中没有找到进程的 page ，就会抛出缺页异常（page fault），调用缺页异常处理程序。比如：
    - 主缺页异常：数据还没有被 MMU 载入内存，需要等待磁盘 IO 。
    - 次缺页异常：数据被载入内存了但是找不到，或不能访问。

### OOM

：Out of Memory ，Linux 内核提供的一种服务，用于在系统内存不足时自动杀死某些进程。
- 杀死进程时是发送 SIGKILL 信号。
- OOM 会给每个进程评一个 oom_score 分数，取值为 0~1000 。
  - 进程占用的内存越多，其 oom_score 的值越大，被 OOM 杀死的可能性越大。
  - 可以通过 `/proc/<pid>/oom_score` 文件查看、修改进程的 oom_score 。
  - 可以执行 `grep 'Out of memory' /var/log/messages` 查看 OOM 的执行日志。

### Buffer

：内存中的一块区域，用于缓冲内存向磁盘读写的所有数据。
- 优点：
  - 内存将数据累积到一定量之后再读取、写入磁盘，降低磁盘的 IO 频率，减少内存等待磁盘 IO 的耗时。

### Cache

：CPU 中的一块区域，用于缓存 CPU 经常向内存读写的数据。
- CPU 执行某个指令时，如果需要读取某数据，则先尝试到 Cache 中查找该数据。分为两种情况：
  - Cache Hit ：在 Cache 中找到了，则可以立即读取该数据。
    - 内核会根据 LRU 算法来自动清理缓存的数据，提高 CPU 读取数据时的 Hit 命中率。
  - Cache Miss ：在 Cache 中没找到，则到内存中查找该数据。
- 一般的计算机中，几个模块的 IO 速度具有很大差距：CPU 寄存器 > Cache >> 内存 >> 磁盘 。
  - 容量则相反。磁盘的 IO 速度最慢，但成本最低，因此相同价格时的容量最大。
  - 使用 Cache 时，可以避免 CPU 直接读写内存、磁盘，减少 CPU 等待 IO 的时间。
  - 内核读写磁盘中的数据时，总是要经过 Buffer ，但只有部分数据会载入 Cache 。
- 目前的 CPU Cache 一般采用 SRAM 介质，容量为几 MB 。
  - 一般存在多级缓存。例如 L1、L2、L3 三级缓存，CPU 先到 L1 Cache 中读取数据，如果 Miss 了再到 L2 Cache 中读取数据，以此类推。

- 系统运行一段时间之后，Cache 会越来越大，而 free 内存越来越少。此时提高了 RAM 内存的利用率，并不需要主动清理 Cache 。
  - 可以执行以下命令，主动让内核清理一次缓存，不过之后内核又会重新建立缓存：
    ```sh
    echo 1 > /proc/sys/vm/drop_caches   # 清除 Page Cache
    echo 2 > /proc/sys/vm/drop_caches   # 清除 Reclaimable slab
    echo 3 > /proc/sys/vm/drop_caches   # 清除 Page Cache、Reclaimable slab
    ```

- 脏页（dirty pages）
  - ：指从磁盘读取到 Cache 中的数据，被 CPU 修改了，与磁盘中的原数据不一致，需要写入磁盘保存。
  - Linux 系统会等 dirty pages 达到一定数量时，才写入磁盘，以减少写磁盘的耗时。
  - CPU 修改 Cache 中的数据时，会自行保证与内存中数据的一致性，但不会保证与磁盘中数据的一致性，因此存在 dirty pages 。

### 内存消耗

- 主机的物理内存，大部分被进程消耗，少部分被内核消耗。
  - 进程占用的内存包括：
    ```sh
    process resident memory   # 主要因素，包括共享内存
    ```
  - 内核占用的内存包括：
    ```sh
    Kernel Modules    # 内核模块，可用 lsmod 命令查看
    Kernel Stack      # 内核会给每个线程分配一个栈区，程序陷入内核态之后才可以访问，默认为 16KB
    Page Tables       # MMU 为每个进程都维护了一张页表

    Buffers
    Cached
    Slab
    Sockets           # 每个 Socket 占用 3 KB 内存左右，但缓冲区满了时会占用 200 KB 左右

    ...
    ```

- 通过 `/proc/meminfo` 文件可以获取主机内存的使用情况。
  - 但它不会统计以下内存：
    - Socket 内存
    - 通过 `alloc_pages()` 分配的内存

## 进程内存

### 虚拟内存空间

- Linux 中，每个进程都运行在一个独立的虚拟内存空间中，就像系统中只有它一个进程。
  - 注意它属于一个逻辑概念，并没有实际占用物理内存。与 Windows 的虚拟内存不同，后者类似于 Linux 的 Swap 分区。

- 例如：在一个 32 位、4G 内存的系统中，每个进程独享一个 4G 的虚拟内存空间。
  - 高地址的 1G 空间为内核内存空间，只能被内核态进程访问。
  - 低地址的 3G 空间为用户内存空间，可以被用户态进程访问。
    - 用户空间又分为五个部分：文件映射区、数据区（存储全局变量等）、只读区（存储代码、常量等）、堆区、栈区。
    - 不同进程之间访问不到对方的用户内存空间，只能通过内核内存空间进行通信。

### 相关概念

- VIRT ：Virtual Memory ，进程申请分配的虚拟内存，对应虚拟内存空间。
- RSS ：Resident Set Size ，进程的常驻集大小，即在 RAM 中实际占用的内存。
  - 例如：进程申请了 100M 内存，实际只使用了 10M ，则 VIRT 为 100M ，而 RSS 为 10M 。
  - RSS = SHR + 进程独自占用的非共享内存
  - RSS 包括堆、栈、共享内存，不包括 Swap ，也不包括 page tables、huge page、kernel stack、struct thread_info、struct task_struct 等。
  - 用如下命令可以统计所有进程的 RSS 内存之和，但这样会重复累计 SHR 内存，因此比所有进程实际占用的内存量偏大。应该统计 PSS 内存之和。
    ```sh
    ps -eo rss | awk 'NR>1' | awk '{sum+=$1} END {print sum/1024}'
    ```
- PSS ：Proportional Set Size ，进程的比例集大小。
  - PSS = 进程平均占用的 SHR + 进程独自占用的非共享内存
  - 例如：进程 A 独自占用的非共享内存为 8M ，与其它 N 个进程共享 2M 的共享内存，则进程 A 的 PSS = 9 + 2/(N+1) MB 。

- SHR ：Shared Memory ，进程使用的共享内存，属于 RES 。
  - 比如多个进程可能导入同一个共享库 glibc 。
  - 讨论 VIRT、RSS、PSS、SHR 时，都不包括 Swap 分区。

## 相关命令

### free

```sh
$ free            # 显示主机内存的使用情况
      -k          # 采用 KB 作为显示单位（默认）
      -m          # 采用 MB 作为显示单位
      -h          # --human ，自动调整显示单位
      -w          # 拉宽显示，将 buffers 与 cache 列分别显示
      -s 1 -c 10  # 每隔一秒显示一次，最多显示 10 次
```
- 例：
  ```sh
  [root@Centos ~]# free -wh
                total        used        free      shared  buff/cache   available
  Mem:           7.6G        5.9G        187M        496K        1.6G        673M
  Swap:          4.0G        1.8G        2.2G
  ```
  - total ：物理内存的总可用量。
    - 内核 Boot 阶段占用的内存，比如内核代码，称为 Reserved ，不计入 MemTotal 。因此 MemTotal 比内存设备的实际容量偏低。
  - used ：已被占用的物理内存。
    - free 命令会先从 `/proc/meminfo` 读取 MemTotal、MemFree、Buffers、Cached、Slab 信息，然后按 `used = total - free - buffer - cache` 计算出已用内存。
  - free ：空闲内存。表示既没有被进程使用，也没有被划分成缓存的内存。
    - free 内存较少并不代表物理内存紧张，因为系统在必要时可以回收大量缓存。
    - 当 available 内存较少、甚至 Swap 分区被使用时，才说明物理内存紧张。
  - shared ：共享内存，属于 used 内存。
  - buffers ：Buffer 内存。
  - cache ：free 命令统计的 cache 内存是指 Page Cache + Slab 内存。
  - available ：可用内存，包括 free 内存和可以被回收的 buff/cache 。
    - 该值是估算的，并不准确。

### sync

```sh
$ sync            # 将 Buffer 中的数据立即写入磁盘
```
- 默认会等缓冲满了才写入磁盘，如果此时系统断电就会丢失数据。

### pmap

```sh
$ pmap  <pid>     # 显示一个进程的虚拟内存空间的内存映射表
        -x        # 增加显示 RSS、Dirty Page 列
```
- 例：
  ```sh
  [root@Centos ~]# pmap 1 -x
  1:   /usr/lib/systemd/systemd --switched-root --system --deserialize 22
  Address           Kbytes     RSS   Dirty    Mode    Mapping
  0000557a0dbf2000    1424    1208       0    r-x--   systemd
  0000557a0df56000     140     132     132    r----   systemd
  0000557a0df79000       4       4       4    rw---   systemd
  0000557a0f80b000    1224    1124    1124    rw---     [ anon ]
  00007f1878000000     164      12      12    rw---     [ anon ]
  00007f1878029000   65372       0       0    -----     [ anon ]
  ```
  表中每行描述一块内存空间，大小不一。
  - Address ：表示该内存空间的首地址。
  - Mapping ：表示该内存空间的用途。
    - 取值为 `[ anon ]` 表示程序申请分配的内存。
    - 取值为 `[ stack ]` 表示堆栈。
    - 其它取值表示用于存储文件。
