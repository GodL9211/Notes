# 内存

：Memory ，又称为内部存储器、主存储器、物理内存。
- 内存能被 CPU 直接读写，用于暂时保存 CPU 处理的数据。
- 内存一般比外存的读写速度快，但是存储容量小。
- 一个内存条包含几个内存芯片以及外围电路，每个内存芯片中都集成了大量的内存颗粒。

## 存储技术

内存的存储技术主要分为两种：
- 只读存储器（Read Only Memory ，ROM）
  - ：只能读取数据，不能写入数据。但是断电后数据不会丢失，因此能永久地保存数据。
  - 目前只有嵌入式设备、BIOS 等少数场景会使用 ROM 。

- 随机存储器（Random Access Memory ，RAM）
  - ：可以在任意位置读、写数据。但是断电后数据就会丢失。
  - 电脑、手机的内存通常都是采用 RAM 。

## Buffer

：内存中的一块区域，用于缓冲 CPU 要写入磁盘的数据。
- 优点：
  - 让 CPU 与磁盘异步工作，不必等待磁盘 IO 。
  - 将数据累积到一定量之后再写入磁盘，降低磁盘的 IO 压力。
- 一般的计算机中，内存的读写速度比磁盘快很多，而 CPU 的读写速度又比内存快很多。如果 CPU 直接读写内存或磁盘，就要浪费时间去等待对方。因此应该让 CPU 使用缓冲。

## Cache

：内存中的一块区域，用于缓存 CPU 从磁盘读取的数据，便于再次读取。
- 当 CPU 要读取某个数据时，会先到 Cache 中寻找它。有以下两种情况：
  - cache hit ：在 Cache 中找到了，便可以立即读取它，节约了时间。
  - cache miss ：在 Cache 中没找到，此时需要从磁盘载入内存。
- 例：
  - CPU 第一次启动一个进程时会将进程的数据保存一份到 cache 中，当下一次启动该进程时会从 cache 中更快地载入，从而提高 CPU 的载入速度。
  - 系统运行一段时间之后，cache 会越来越大，占用越来越多的 free 内存。这样能提高内存使用率。
- CPU 通常根据 LRU 算法来自动清理缓存的数据，提高 CPU 读取数据时的 cache hit 率。

## 内存管理

### MMU

：内存管理单元。
- 以 page 为单位管理内存，每个 page 为 4 KB 。
- 当 page 数不足时，MMU 可能采用三种措施：
  - 回收最近不用的 page 。
  - 将不常用的内存数据从 page 移到 swap 分区。
  - 通过 OOM 杀死某些占用大量内存的进程。
- MMU 为每个进程都维护了一张页表（page table），将虚拟内存中要用到的内容映射到物理内存的一些 page 中，供 CPU 访问。
  - 这些 page 的集合称为该进程的 working set 。
  - 如果 CPU 在内存中没有找到进程的 page ，就会抛出缺页异常（page fault），调用缺页异常处理程序。这可能是因为数据还没有被 MMU 载入内存（称为主缺页异常，需要等待磁盘 IO）、数据被载入内存了但是找不到或不能访问（称为次缺页异常）。
  - 当程序申请动态分配一块内存时，并不会立即获得该内存，而是等到它使用该内存时，CPU 会发现该内存不存在而报出缺页异常，MMU 才将实际内存分给它。
- dirty page ：从磁盘加载到缓存中的数据被 CPU 改动了，与磁盘中的原数据不一致，需要写入磁盘保存。

### OOM

：Out of Memory ，Linux 内核提供的一种服务，用于在系统内存不足时自动杀死某些进程。
- 杀死进程时是发送 SIGKILL 信号。
- OOM 会给每个进程评一个 oom_score 分数，取值为 0~1000 。
  - 进程占用的内存越多，其 oom_score 的值越大，被 OOM 杀死的可能性越大。
  - 可以通过 `/proc/<pid>/oom_score` 文件查看、修改进程的 oom_score 。
  - 可以执行 `grep 'Out of memory' /var/log/messages` 查看 OOM 的执行日志。

### 虚拟内存空间

每个进程都运行在一个独立的虚拟内存空间中，就像系统中只有它一个进程。

例如：在一个 32 位、4G 内存的系统中，每个进程独享一个 4G 的虚拟内存空间。
- 高地址的 1G 空间为内核内存空间，只能被内核态进程访问。
- 低地址的 3G 空间为用户内存空间，可以被用户态进程访问。
  - 用户空间又分为五个部分：文件映射区、数据区（存储全局变量等）、只读区（存储代码、常量等）、堆区、栈区。
  - 不同进程之间访问不到对方的用户内存空间，只能通过内核内存空间进行通信。

## 相关命令

### free

```sh
$ free            # 显示内存的使用情况
      -h          # 以人类容易阅读的单位显示文件大小（默认单位为 KB）
      -w          # 拉宽显示更多信息
      -s 1 -c 10  # 每隔一秒显示一次，最多显示 10 次
```
- 例：
  ```sh
  [root@Centos ~]# free -wh
                total        used        free      shared     buffers       cache   available
  Mem:           7.8G        7.1G        543M         17M         33M        190M        636M
  Swap:            0B          0B          0B
  ```
  - total ：物理内存的总量。total = used + free + buffer + cache
  - used ：已用内存。
  - free ：空闲内存。表示既没有被使用，也没有被划分成缓存的内存。
  - shared ：共享内存，被多个进程共享。
  - buffers
  - cache
  - available ：可用内存，包括 free 内存和可被回收的缓存。
- free 内存较少并不代表物理内存紧张，因为系统可以回收大量缓存。当 available 内存较少、甚至 Swap 分区被使用时，才说明物理内存紧张。

### sync

```sh
$ sync    # 将 Buffer 中的数据立即写入磁盘
```
- 默认会等缓冲满了才写入磁盘，如果此时系统断电就会丢失数据。
