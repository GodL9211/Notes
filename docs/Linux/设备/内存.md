# 内存

：Memory，又称为内部存储器、主存储器。
- 内存能被CPU直接读写，用于暂时保存CPU正在处理的数据。
- 内存一般比外存的读写速度快，但是存储容量小。
- 一个内存条包含几个内存芯片以及外围电路，每个内存芯片中都集成了大量的内存颗粒。

## 分类

- ROM（Read Only Memory）：只读存储器，用于永久性地保存一些数据（比如BIOS），断电后数据不会丢失。
- RAM（Random Access Memory）：随机存储器，可以在任意位置读写数据，断电后数据就会丢失。

## 缓存

：Cache Memory，一般比内存的读写速度更快。
- Cache可能集成在CPU之内，也可能集成在CPU之外的主板上。
- CPU会将一些需要经常读取的数据暂存在Cache中，这样比从内存或磁盘中读取更快。
  - 当CPU要读取某个数据时，先去Cache中寻找，如果没找到再去内存中寻找，如果内存中也没有再从磁盘载入。
  - 如果在Cache中找到了，就称为“cache hit”，如果没找到就称为“cache miss”。
  - CPU会根据LRU算法将最近常用的数据暂存在Cache中，大概率提高CPU读取数据时的cache hit命中率。

## 物理内存
- Memory：物理内存。
  - 物理内存的总量total = used + free + buffer + cache。
  - MMU：内存管理单元。以page为单位管理内存，每个page为4KB。
- Swap：磁盘上的一部分区域，称为交换区，功能相当于Windows系统的磁盘虚拟内存。
  - 当page数不足时，MMU会将page中某些暂时不用处理的数据暂时移到Swap分区中（称为swap out）。
  - Windows中即使没用完物理内存也可能使用虚拟内存，而Linux中只有用完了物理内存才会使用swap分区。
  - 分配一些Swap分区有利于维持系统的稳定，但是Swap交换会导致CPU读写数据变慢，还会增加磁盘IO。
  - 为了保证CPU能一直从内存中快速读取数据，最好禁用swap。
- 共享内存：一种特殊的缓存，被多个进程共享，用于存储动态链接库等。
## 缓存。
- 缓存区是物理内存中读写速度最快的区域。
  - 读缓存可以实现内存和磁盘的异步工作，避免等待磁盘IO，从而保持内存的高读取速度。
  - 写缓存可以将大量小数据累积之后再写入磁盘，降低磁盘的IO压力。
- buffer：用于从磁盘读写数据时的缓存，比如存储文件的属性。
- cache：用于从文件读写数据时的缓存。
  - 当CPU读取cache时有两种情况：
cache hit：找到了需要读取的数据，则从cache中快速读取。
cache miss：没有找到需要读取的数据，说明数据放在其它位置，要等待加载。
  - CPU第一次启动一个进程时会将进程的数据保存一份到cache中，当下一次启动该进程时会从cache中更快地载入。这样能提高CPU的载入速度。
  - 系统运行一段时间之后，cache会越来越大，占用越来越多的free内存。这样能提高内存使用率。
  - 输入命令sync可以将缓存中的数据立即写入磁盘，减少buffer和cache。
- dirty page：从磁盘加载到缓存区的数据被改动了，需要写入磁盘保存。
## 内存不足。
- 当page数不足时，MMU可能采用三种措施：
  - 回收最近不用的page。
  - 将不常用的内存数据从page移到swap分区。
  - 通过OOM杀死某些占用大量内存的进程。
- OOM（Out of Memory）：一种管理内存的机制，用于在内存不止时自动杀死某些进程。
  - 给每个进程评一个oom_score，进程占用的内存越多、占用的CPU越少，其oom_score的值越大，越容易被OOM杀死。
  - 用户可以手动设置进程的oom_score。
## 每个进程都运行在一个独立的虚拟内存空间中，就像系统中只有它一个进程。
- 比如在一个32位、4G内存的系统中，每个进程独享一个4G的虚拟内存空间，其中高地址的1G空间为内核内存空间，只能被内核态进程访问；低地址的3G空间为用户内存空间，可以被用户态进程访问。
  - 用户空间又分为五个部分：文件映射区、数据区（存储全局变量等）、只读区（存储代码、常量等）、堆区、栈区。
  - 不同进程之间访问不到对方的用户内存空间，只能通过内核内存空间进行通信。
- MMU为每个进程都维护了一张页表（page table），将虚拟内存中要用到的内容映射到物理内存的一些page中，供CPU访问。
  - 这些page的集合称为该进程的working set。
  - 如果CPU在内存中没有找到进程的page，就会抛出缺页异常（page fault），调用缺页异常处理程序。这可能是因为数据还没有被MMU载入内存（称为主缺页异常，需要等待磁盘IO）、数据被载入内存了但是找不到或不能访问（称为次缺页异常）。
  - 当程序申请动态分配一块内存时，并不会立即获得该内存，而是等到它使用该内存时，CPU会发现该内存不存在而报出缺页异常，MMU才将实际内存分给它。
## 
## 
## 
 
相关命令
## 关于内存的命令。
- free      # 显示内存的使用情况
-h    # 转换成人类易读的单位（内存的默认单位为KB）
-w    # 拉宽显示更多信息
-s 1 -c 10  # 每隔一秒显示一次，最多显示10次
 
  - total  ：内存总量
  - used    ：已用内存。
  - free    ：空闲内存。表示既没有被使用，也没有被划分成缓存的内存。
  - shared
  - buffers
  - cache
  - available：可用内存，包括free内存和可被回收的缓存。
Mem free较少并不意味着物理内存紧张，因为系统可以回收大量缓存。当avail Mem较少、Swap分区被使用时才说明物理内存紧张。
- sync        # 将缓存中的数据块立即写入磁盘（否则会等缓存满了才写入，当系统断电时会丢失数据）

```
[root@Centos ~]# free -wh
              total        used        free      shared     buffers       cache   available
Mem:           1.8G        519M         69M        652K        202M        1.0G        1.1G
Swap:            0B          0B          0B
```
