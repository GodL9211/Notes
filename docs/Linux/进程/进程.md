# 进程

## 程序

- 程序（Program）是一组可以被 CPU 执行的计算机指令。
  - 比如在 Windows 系统上双击启动一个软件、在 Linux 系统上执行一条命令，都是启动一个程序。
- 程序被 CPU 执行时，主要分为以下几个阶段：
  - 启动 ：开始执行。
  - 运行 ：正在执行。
    - CPU 不一定会一直执行同一个程序，可能暂停执行它，转去执行其它程序，一段时间后再回来继续执行它。
  - 结束 ：终止执行（不是暂停执行），并返回一个退出码。也称为程序退出、终止。
- 程序终止的几种情况：
  - 执行完所有指令，正常退出。此时退出码为 0 。
  - 调用 exit() 函数，提前退出。此时退出码由程序决定。
  - 接收到 SIGTERM 等信号，被杀死。
- 操作系统一般要求程序结束执行时返回一个整数值，称为退出码（Exit Code）、返回码（Return Code），用于表示程序的执行结果。
  - Shell 中程序退出码的取值范围为 0~255 ，通常取值为 0 时表示正常退出，取值为非 0 时表示异常退出。

## 进程

- 进程（Process）是程序运行、分配系统资源的最小单位。
  - 启动一个程序时，至少要创建一个进程，来执行程序指令。
  - 当进程执行程序指令时，实际上是由进程中的线程，在 CPU 中执行。
- 每个进程（称为父进程）可以创建任意个其它进程（称为子进程）。
  - 父进程及其所有子进程属于同一个进程组。
  - 当父进程终止时，内核并不会自动杀死子进程。

### 守护进程

- 前台进程
  - ：绑定到当前终端的 stdin ，因此会阻塞当前终端。
  - 普通方式启动的进程默认会绑定到当前终端的 stdin、stdout、stderr 。
- 后台进程
  - ：没有绑定到终端的 stdin ，但可能绑定了 stdout、stderr 。
  - 前台进程、后台进程都是当前终端的子进程。如果用户关闭当前终端，系统就会给这些进程发送 SIGHUP 信号，终止它们。
- 守护进程（daemon）
  - ：一种特殊的后台进程。运行在一个独立的 Process Session 中，完全脱离用户的终端，不会收到 SIGHUP 信号。
  - 系统服务程序通常以守护进程的方式运行。

## 进程组

：Process Group ，包含一个进程，或多个具有父子关系的进程。
- 每个进程组中有且仅有一个 Leader 进程，是其它进程的父进程。

## 进程会话

：Process Session ，包含一个进程组，或多个具有父子关系的进程组。
- 会话中的进程组又称为 job ，用于完成某种任务。
- 一个 Session 中有且仅有一个 Leader 进程，是其它进程、进程组的根父进程。
  - 当 Session Leader 终止时，系统会给该 Session 的所有进程发送 SIGHUP 信号来终止它们。当 Session 中的所有进程都终止时，系统就会删除该 Session 。
- 例如：用户登录时会创建一个 login shell ，还会创建一个 Session ，以 login shell 作为 Session Leader 。
  - 在该 Session 中，只有一个进程组能工作在前台，其它进程组都只能工作在后台。
  - 当用户登出时，属于该 Session 的所有进程组都会被系统终止。
- 相关函数：
  ```c
  #include <unistd.h>

  pid_t setsid(void);
      // 创建一个新的进程会话，然后返回其 SID
      // 创建的新会话中，由当前进程担任 Group Leader 和 Session Leader
      // 如果当前进程本来就是当前进程组的 Group Leader ，则不允许创建，避免与当前进程组的其它进程处于不同的会话中
  ```

## 进程的符号

### 标识符

Linux 系统会给每个进程、线程分配一个标识符（ID），包括：
- PID ：进程的 ID ，在整个系统中唯一。
- PPID ：父进程的 ID 。
- TID ：线程的 ID ，在其线程组中唯一。
- PGID ：进程组（Process Group）的 ID ，等于其主进程的 ID 。
- TGID ：线程组（Thread Group）的 ID ，等于其主线程的 ID 。
- SID ：Process Session 的 ID ，等于其主进程的 PID 。

### 进程类型

- s ：该进程是 Session Leader 。
- \+ ：该进程属于前台进程。
- < ：high-priority (not nice to other users)。
- N ：low-priority (nice to other users)。
- L ：已锁定内存中的 page 。
- l ：是多线程的。

### 运行状态

- R ：Running
  - 进程处于 Running 状态时才会占用 CPU 。
- S ：Sleeping
  - 此时进程处于可中断的睡眠状态，被 CPU 挂起，等到某一时刻或满足某些条件时再继续运
  - 例如，HTTP 服务器通常一直处于 Sleeping 状态，收到 HTTP 请求时才有一瞬间切换到 Running 状态。
- D ：Disk Sleep
  - 此时进程处于不可中断的睡眠状态，不会响应异步信号，因此不能被 kill -9 杀死。
  - 例如，进程等待磁盘 IO 时，会进入短暂的 D 状态。
- I ：Idle ，即空闲状态。
- Z ：Zombie ，僵尸进程。
- T ：Stopped ，暂停状态。
- t ：Traced ，比如进程被断点调试时处于被跟踪状态。
- X ：进程正在终止，这是一个很短暂的状态。

## 相关 API

- Linux 中，每个进程采用一个名为 task_struct 的结构体记录其信息，称为进程控制块（Process Control Block，PCB）、进程描述符。如下：
  ```c
  struct task_struct
  {
      volatile long state;              // 进程的运行状态
      void *stack;                      // 进程的内核栈
      atomic_t usage;                   // 进程描述符的使用计数
      unsigned int flags;               // 进程的状态标志

      int prio;                         // 进程的 CPU 调度的优先级
      unsigned int policy;              // 进程的 CPU 调度策略，比如按时间轮转、先来后到
      cpumask_t cpus_allowed;           // 进程可以在 CPU 的哪些核上执行

      int exit_state;                   // 进程的退出码
      pid_t pid;                        // 进程的标识符

      struct task_struct *parent;       // 一个指针，指向父进程
      struct task_struct *group_leader; // 一个指针，指向当前进程组的主进程
      struct list_head children;        // 一个链表，其中每个元素表示一个子进程

      cputime_t utime, stime;           // 进程占用的用户态、内核态 CPU 时长
      struct timespec start_time;       // 进程的启动时刻
      
      ...
  }
  ```

- 关于创建进程：
  ```c
  #include <unistd.h>

  pid_t fork(void);
      // 拷贝当前进程，创建一个子进程
      // 如果创建成功，则在父进程中返回子进程的 PID ，在子进程中返回 0
      // 如果创建失败，则返回 -1
  ```
  - 调用 fork() 创建的子进程，与父进程几乎完全相同，比如：
    - 拷贝父进程的虚拟内存空间。
    - 拷贝父进程打开的文件描述符。
  - 调用 fork() 创建的子进程，是一个独立的新进程，与父进程存在少量差异，比如：
    - 拥有不同的 PID 。
    - 将资源使用率、CPU 使用时长重置为零，重新计算。
    - 将待处理的信号集清空。

- 关于执行程序：
  ```c
  #include <unistd.h>

  int execve(const char *pathname, char *const argv[], char *const envp[]);
      // 执行 pathname 对应的二进制文件，并传入参数 argv 、环境变量 envp
  ```
  - 调用 execve() 时，是执行另一个程序，替换当前程序。
    - 这会覆盖当前进程的数据段、堆栈。不过进程的 PID 不变，已经打开的文件描述符会保留。
  - 例如：在终端执行 `ls -l` 命令时，是先调用 `fork()` 创建子进程，而子进程再执行 `execve("/usr/bin/ls", ["ls", "-l"], 0x7ffc0e3d0910 /* 29 vars */)` 。

- 关于终止进程：
  ```c
  #include <stdlib.h>

  void exit(int status);
      // 使当前进程退出，且退出码取值为 status
  ```

- 关于等待进程退出：
  ```c
  #include <sys/wait.h>

  pid_t wait(int *status);
    // 阻塞当前线程，直到一个子进程退出，然后返回其 PID
    // 如果没有子进程或执行失败，则返回 -1

  pid_t waitpid(pid_t pid, int *status, int options);
    // 阻塞当前线程，直到指定子进程的运行状态改变（默认是等待变为 terminated 状态）
  ```
  - pid
    - 如果为 n > 0 ，则等待 PID 等于 n 的子进程。
    - 如果为 0 ，则等待当前进程的任一子进程。
    - 如果为 -1 ，则等待任一子进程。
    - 如果为 -n < -1 ，则等待 PGID 等于 n 的进程组中的任一子进程。
  - 例：
    ```c
    wait(NULL);               // 相当于 waitpid(-1, NULL, 0);
    while (wait(NULL) > 0);   // 阻塞当前线程，直到所有子进程都退出
    ```
  - 例：
    ```c
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/wait.h>

    int main(){
        pid_t pid;
        pid = fork();         // 此时拷贝了一个子进程，往下的代码是主进程、父进程同时各执行一份
        if (pid < 0)
            printf("Failed to fork");
        else if (pid == 0)
            printf("This is child process: [%d] . Its parent process is [%d] \n", getpid(), getppid());
        else{
            printf("This is parent process: [%d] . It just created a child process: [%d] \n", getpid(), pid);
            pid = wait(NULL); // 等待子进程终止
            printf("The child process [%d] has terminated.\n", getpid(), getppid(), pid);
        }
        return 0;
    }
    ```
    运行结果：
    ```sh
    This is parent process: [9961] . It just created a child process: [9962]
    This is child process: [9962] . Its parent process is [9961]
    The child process [9961] has terminated.
    ```
