# 进程

## 程序

- 程序（Program）是一组可以独立执行的计算机指令。
  - 比如在 Windows 系统上双击启动一个软件、在 Linux 系统上执行一条命令，都是启动一个程序。
- 程序被 CPU 时，主要分为以下几个阶段：
  - 启动 ：开始执行。
  - 运行 ：正在执行。
    - CPU 不一定会一直持续执行一个程序，可能暂停执行它，转去执行其它程序，一段时间后再回来继续执行它。
  - 结束 ：停止执行，并返回一个退出码（不是暂停执行）。
    - 程序结束可能是因为正常执行完所有指令，也可能是因为执行出错而异常退出。
    - 操作系统通常要求程序结束时返回一个整数值，称为返回码、退出码（exit code），用于表示程序结束运行的状态。就像调用 C 语言函数之后会得到一个返回值，取值为 0 时表示正常运行结束。

## 进程

- 进程（Process）是程序运行时的最小单位。
  - 启动一个程序时，至少要创建一个进程，来执行程序指令。
  - 程序中第一个创建的进程称为主进程。

- 每个进程（称为父进程）都可以创建其它进程（称为子进程）。
  - 父进程及其所有子进程属于同一个进程组。
    - 它们是平级关系。当父进程结束时，系统并不会自动杀死子进程。
    - 当一个进程组中的所有进程都结束时，系统才会删除该进程组的存在。
  - 操作系统通常会提供创建进程的 API ，可以在程序代码中调用。比如 Linux 是 `fork()`，Windows 是 `CreateThread()` 。

- 同一个主机的进程之间可以使用以下通信媒介：
  - 文件
  - 管道文件
  - 共享内存

### 守护进程

- 前台进程
  - ：绑定到当前终端的 stdin ，因此会阻塞当前终端。
  - 普通方式启动的进程默认会绑定到当前终端的 stdin、stdout、stderr 。
- 后台进程
  - ：没有绑定到终端的 stdin ，但可能绑定了 stdout、stderr 。
  - 前台进程、后台进程都是当前终端的子进程。如果用户关闭当前终端，系统就会给这些进程发送 SIGNUP 信号，终止它们。
- 守护进程（daemon）
  - ：一种特殊的后台进程。运行在一个独立的 Session 中，完全脱离用户的终端，不会收到 SIGNUP 信号。
  - 系统服务程序通常以守护进程的方式运行。

## 线程

- 线程（Thread）是进程运行时的最小单位。
  - 创建一个进程时，至少要创建一个线程，来执行该进程要执行的程序指令。
  - 进程中第一个创建的线程称为主线程。

- 每个线程（称为父线程）都可以创建其它线程（称为子线程）。
  - 父线程及其所有子线程属于同一个进程。
    - 它们是从属关系。当父线程结束时，系统会自动杀死所有子线程。
    - 当一个进程中的所有线程都结束时，系统就会删除该进程的存在。
  - 每个线程也可以创建其它进程，不过此时看作是该线程所属的进程创建了其它进程。

- 同一个进程的线程之间可以使用 “全局变量” 作为通信媒介，因为它们共用一个堆，都可以访问堆中存储的全局变量。



- 操作系统会为每个进程分配单独分配内存、Socket 等系统资源，为每个线程单独分配 CPU 占用时间。
  - 一个进程中的所有线程会共享该进程被分配的系统资源，共用一个堆，但是有各自独立的栈。
- 线程是 CPU 调度的基本单位。系统会决定由 CPU 的哪个核来执行线程、执行多长时间。



<!-- 系统在内存中划分堆栈 -->


<!-- 
多进程
- 优点：
- 缺点：


多线程
- 优点：可以提高 CPU 的使用率。
  - 比如一个线程因为等待 IO 而暂停运行时，其它线程依然可以运行。
  - 比如一个线程占用了 CPU 的一个核时，其它线程可以在 CPU 的其它核上运行。
- 缺点：线程数过多会导致 CPU 切换线程的开销过大。
  - CPU 切换进程时，不仅需要切换运行的线程，还需要切换进程所分配的内存、堆栈等资源。
 -->


### 线程安全

：运行多线程时，多个线程的运行顺序无法确定（这取决于CPU的调度），因此要考虑以下问题。
- 一个线程在执行任务时可能被其它线程打断。
  - 可以阻塞其它线程，先让该线程运行完该任务。
- 一个线程在访问共享资源时，该资源可能被其它线程修改。
  - 可以给该资源上锁，保证同时只被一个线程访问。




## 进程组

：Process Group ，包含一个或多个具有父子关系的进程。
- 一个进程组中有且仅有一个 Leader 进程，是其它进程的父进程。

## 进程会话

：Session ，包含一个或多个具有父子关系的进程组。
- 一个 Session 中有且仅有一个 Leader 进程，是其它进程、进程组的根父进程。
- 会话中的进程组又称为 job ，用于完成某种任务。
- 当 Session Leader 终止时，系统会给该 Session 的所有进程发送 SIGHUP 信号来终止它们。当 Session 中的所有进程都终止时，该 Session 就宣告消失。
- 例如：用户登录时会创建一个 login shell ，还会创建一个 Session ，以 login shell 作为 Session Leader 。
  - 在该 Session 中，只有一个进程组能工作在前台，其它进程组都只能工作在后台。
  - 当用户登出时，属于该 Session 的所有进程组都会被系统终止。

## PID

Linux 系统会给每个进程、线程分配一个标识符（ID）。
- PID ：进程的 ID ，在整个系统中唯一。
- PPID ：父进程的 ID 。
- TID ：线程的 ID ，在其线程组中唯一。
- PGID ：进程组（Process Group）的 ID ，等于其 Leader 进程的 PID 。
- TGID ：线程组（Thread Group）的 ID ，等于其 Leader 进程的 PID 。
- SID ：Session 的 ID ，等于其 Leader 进程的 PID 。

## 进程的运行状态

- R ：Running
  - 进程处于 Running 状态时才会占用 CPU 。
- S ：Sleeping
  - 此时进程处于可中断的睡眠状态，被 CPU 挂起，等到某一时刻或满足某些条件时再继续运
  - 例如，HTTP 服务器通常一直处于 Sleeping 状态，收到 HTTP 请求时才有一瞬间切换到 Running 状态。
- D ：Disk Sleep
  - 此时进程处于不可中断的睡眠状态，不会响应异步信号，因此不能被 kill -9 杀死。
  - 例如，进程等待磁盘 IO 时，会进入短暂的 D 状态。
- I ：Idle ，即空闲状态。
- Z ：Zombie
  - 僵尸进程已经运行结束，但进程描述符还存在，说明父进程还没有回收它的资源。
  - 如果父进程没有正确回收子进程，还不断创建子进程，就会占用越来越多的系统资源。即使这些子进程自己运行结束了，变成僵尸进程，也可能耗尽系统的 PID ，导致系统不能创建新进程。
  - 如果父进程运行结束，init 进程会自动回收它的所有子进程。
- T ：Stopped ，暂停状态。
- t ：Traced ，比如进程被断点调试时处于被跟踪状态。
- X ：进程正在终止，这是一个很短暂的状态。

## 进程的标志符

- s ：该进程是 Session Leader 。
- `+` ：该进程属于前台进程。
- < ：high-priority (not nice to other users)。
- N ：low-priority (nice to other users)。
- L ：已锁定内存中的 page 。
- l ：是多线程的（使用 CLONE_THREAD）。

## 进程间通信

Linux 系统上，进程间通信（Inter Process Communication ，IPC）的主要方式如下：

### 信号

- 信号（signal）可能来源于硬件（比如键盘信号），也可能来源于软件（比如用 kill 命令）。信号产生后，会被内核发送给进程，相当于软件层的模拟中断。
- Linux 内核定义了多种信号，常见的如下：

    编号|宏定义名|默认动作
    -|-|-
    1  | SIGHUP  | 终止进程
    2  | SIGINT  | 终止进程
    3  | SIGQUIT | 终止进程
    9  | SIGKILL | 终止进程
    10 | SIGUSR1 | 终止进程
    12 | SIGUSR2 | 终止进程
    15 | SIGTERM | 终止进程
    19 | SIGSTOP | 暂停进程
    
    - 在不同的平台上，信号的编号可能有差异，因此最好通过宏定义名来指定信号。
    - SIGINT 通常由键盘中断（Ctrl+C）引发。
    - 当内核发出一个普通的终止进程信号时，进程可能立即终止，也可能做完清理工作之后再终止（比如释放占用的资源），甚至不终止。
    - SIGKILL、SIGSTOP 两种信号不能被进程忽略或捕捉，因此一定会立即执行。
    - SIGUSR1、SIGUSR2 两种信号常用于被用户绑定自定义的信号处理函数。
      - SIGUSR1 的默认动作是终止进程，不过 Appache、Nginx 等很多程序收到 SIGUSR1 信号之后会进行复位操作，比如刷新缓存、重新加载配置文件、重新打开日志文件，接近于重启进程。

- 当进程收到一个信号时，有三种处理方式：
  - 执行信号的默认动作
  - 忽略信号
  - 捕捉信号：进程将自己的信号处理函数传给内核，与一个信号绑定。当该信号发生时，内核就会执行该函数，从而实现该进程自定义的动作。如下：
    ```c
    #include <stdio.h>
    #include <signal.h>

    static void sig_handle(int sig_no)  // 定义信号处理函数
    {
        if(sig_no == SIGUSR1)
            printf("Received SIGUSR1\n");
        else
            printf("Received signal %d\n", sig_no);
    }

    int main(void){
        if(signal(SIGUSR1, sig_handle) == SIG_ERR) // 绑定信号处理函数
            printf("Can not catch SIGUSR1\n");     // 如果不能绑定即不能捕捉，则报错
        return 0;
    }
    ```

### 信号量

- ：semophore ，一个非负整数，用于记录某个资源的可用数量。为 0 时表示资源不可用。

### 套接字

- ：Socket

### 管道文件

- 进程可以创建一个管道文件（pipe），和另一个进程同时连接到它，从中读写数据。
- 采用半双工通信，当一个进程写数据时，另一个进程只能读数据。
- 匿名管道（PIPE）：保存在内存中，没有文件描述符，只能用于父子进程之间的通信。比如管道符 | 。
- 命名管道（FIFO）：保存为文件系统中的一个文件，常用于两个独立进程之间的通信。

### 消息队列

- ：message queue ，一个链表结构，允许多个进程从中读写数据。

### 共享内存

- ：shared memory ，一块内存空间，允许多个进程同时访问，读写速度很快。
- 共享内存由内核创建，进程可以把它映射到自己的私有地址空间，从而访问它。
- 当多个进程同时访问共享内存时，需要采取一些措施保证线程之间的同步。
