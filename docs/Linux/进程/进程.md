# 进程

## 程序

- 程序（Program）是一组可以被 CPU 执行的计算机指令。
  - 比如在 Windows 系统上双击启动一个软件、在 Linux 系统上执行一条命令，都是启动一个程序。
- 程序被 CPU 执行时，主要分为以下几个阶段：
  - 启动 ：开始执行。
  - 运行 ：正在执行。
    - CPU 不一定会一直执行同一个程序，可能暂停执行它，转去执行其它程序，一段时间后再回来继续执行它。
  - 结束 ：终止执行（不是暂停执行），并返回一个退出码。也称为程序退出、终止。
- 程序终止的几种情况：
  - 执行完所有指令，正常退出。此时退出码为 0 。
  - 调用 exit() 函数，提前退出。此时退出码由程序决定。
  - 接收到 SIGTERM 等信号，被杀死。
- 操作系统一般要求程序结束执行时返回一个整数值，称为退出码（Exit Code）、返回码（Return Code），用于表示程序的执行结果。
  - Shell 中程序退出码的取值范围为 0~255 ，通常取值为 0 时表示正常退出，取值为非 0 时表示异常退出。

## 进程

- 进程（Process）是程序运行、分配系统资源的最小单位。
  - 启动一个程序时，至少要创建一个进程，来执行程序指令。
  - 当进程执行程序指令时，实际上是由进程中的线程，在 CPU 中执行。
- 每个进程（称为父进程）可以创建任意个其它进程（称为子进程）。
  - 父进程及其所有子进程属于同一个进程组。
  - 当父进程终止时，内核并不会自动杀死子进程。

### 相关函数

- 关于终止进程：
    ```c
    #include <stdlib.h>

    void exit(int status);
        // 使当前进程退出，且退出码取值为 status
    ```

- 关于创建进程：
  ```c
  #include <unistd.h>

  pid_t fork(void);
      // 拷贝当前进程，创建一个子进程
      // 如果创建成功，则在父进程中返回子进程的 PID ，在子进程中返回 0
      // 如果创建失败，则返回 -1
  ```
  - 调用 fork() 创建的子进程，与父进程几乎完全相同，比如：
    - 拷贝父进程的虚拟内存空间。
    - 拷贝父进程打开的文件描述符。
  - 调用 fork() 创建的子进程，是一个独立的新进程，与父进程存在少量差异，比如：
    - 拥有不同的 PID 。
    - 将资源使用率、CPU 使用时长重置为零，重新计算。
    - 将待处理的信号集清空。

- 关于执行程序：
  ```c
  #include <unistd.h>

  int execve(const char *pathname, char *const argv[], char *const envp[]);
      // 执行 pathname 对应的二进制文件，并传入参数 argv 、环境变量 envp
  ```
  - 调用 execve() 时，是执行另一个程序，替换当前程序。
    - 这会覆盖当前进程的数据段、堆栈。不过进程的 PID 不变，已经打开的文件描述符会保留。
  - 例如：在终端执行 `ls -l` 命令时，是先调用 `fork()` 创建子进程，而子进程再执行 `execve("/usr/bin/ls", ["ls", "-l"], 0x7ffc0e3d0910 /* 29 vars */)` 。

### 守护进程

- 前台进程
  - ：绑定到当前终端的 stdin ，因此会阻塞当前终端。
  - 普通方式启动的进程默认会绑定到当前终端的 stdin、stdout、stderr 。
- 后台进程
  - ：没有绑定到终端的 stdin ，但可能绑定了 stdout、stderr 。
  - 前台进程、后台进程都是当前终端的子进程。如果用户关闭当前终端，系统就会给这些进程发送 SIGHUP 信号，终止它们。
- 守护进程（daemon）
  - ：一种特殊的后台进程。运行在一个独立的 Process Session 中，完全脱离用户的终端，不会收到 SIGHUP 信号。
  - 系统服务程序通常以守护进程的方式运行。

## 进程组

：Process Group ，包含一个进程，或多个具有父子关系的进程。
- 每个进程组中有且仅有一个 Leader 进程，是其它进程的父进程。

## 进程会话

：Process Session ，包含一个进程组，或多个具有父子关系的进程组。
- 会话中的进程组又称为 job ，用于完成某种任务。
- 一个 Session 中有且仅有一个 Leader 进程，是其它进程、进程组的根父进程。
  - 当 Session Leader 终止时，系统会给该 Session 的所有进程发送 SIGHUP 信号来终止它们。当 Session 中的所有进程都终止时，系统就会删除该 Session 。
- 例如：用户登录时会创建一个 login shell ，还会创建一个 Session ，以 login shell 作为 Session Leader 。
  - 在该 Session 中，只有一个进程组能工作在前台，其它进程组都只能工作在后台。
  - 当用户登出时，属于该 Session 的所有进程组都会被系统终止。
- 相关函数：
  ```c
  #include <unistd.h>

  pid_t setsid(void);
      // 创建一个新的进程会话，然后返回其 SID
      // 创建的新会话中，由当前进程担任 Group Leader 和 Session Leader
      // 如果当前进程本来就是当前进程组的 Group Leader ，则不允许创建，避免与当前进程组的其它进程处于不同的会话中
  ```

## 标识符

### ID

Linux 系统会给每个进程、线程分配一个标识符（ID），包括：
- PID ：进程的 ID ，在整个系统中唯一。
- PPID ：父进程的 ID 。
- TID ：线程的 ID ，在其线程组中唯一。
- PGID ：进程组（Process Group）的 ID ，等于其主进程的 ID 。
- TGID ：线程组（Thread Group）的 ID ，等于其主线程的 ID 。
- SID ：Process Session 的 ID ，等于其主进程的 PID 。

### 进程类型

- s ：该进程是 Session Leader 。
- \+ ：该进程属于前台进程。
- < ：high-priority (not nice to other users)。
- N ：low-priority (nice to other users)。
- L ：已锁定内存中的 page 。
- l ：是多线程的（使用 CLONE_THREAD）。

### 运行状态

- R ：Running
  - 进程处于 Running 状态时才会占用 CPU 。
- S ：Sleeping
  - 此时进程处于可中断的睡眠状态，被 CPU 挂起，等到某一时刻或满足某些条件时再继续运
  - 例如，HTTP 服务器通常一直处于 Sleeping 状态，收到 HTTP 请求时才有一瞬间切换到 Running 状态。
- D ：Disk Sleep
  - 此时进程处于不可中断的睡眠状态，不会响应异步信号，因此不能被 kill -9 杀死。
  - 例如，进程等待磁盘 IO 时，会进入短暂的 D 状态。
- I ：Idle ，即空闲状态。
- Z ：Zombie ，僵尸进程。
- T ：Stopped ，暂停状态。
- t ：Traced ，比如进程被断点调试时处于被跟踪状态。
- X ：进程正在终止，这是一个很短暂的状态。
