# 进程

## 程序

- 程序（Program）是一组可以被 CPU 执行的计算机指令。
  - 比如在 Windows 系统上双击启动一个软件、在 Linux 系统上执行一条命令，都是启动一个程序。
- 程序被 CPU 执行时，主要分为以下几个阶段：
  - 启动 ：开始执行。
  - 运行 ：正在执行。
    - CPU 不一定会一直持续执行一个程序，可能暂停执行它，转去执行其它程序，一段时间后再回来继续执行它。
  - 结束 ：停止执行（不是暂停执行），并返回一个退出码。也称为程序退出。
    - 程序退出时，可能是因为正常执行完了所有指令，也可能是因为执行出错而异常退出。
- 操作系统通常要求程序结束执行时返回一个整数值，称为退出码（Exit Code）、返回码（Return Code），用于表示程序的执行结果。
  - Shell 中程序退出码的取值范围为 0~255 ，通常取值为 0 时表示正常退出，取值为非 0 时表示异常退出。

## 进程

- 启动一个程序时，至少要创建一个进程，来执行程序指令。
- 进程（Process）是程序运行、分配系统资源的最小单位。

- 每个进程（称为父进程）可以创建任意个其它进程（称为子进程）。
  - 父进程及其所有子进程属于同一个进程组。
    - 它们是平级关系。当父进程结束时，系统并不会自动杀死子进程。
    - 当一个进程组中的所有进程都结束时，系统才会删除该进程组的存在。
  - 操作系统通常会提供创建进程的 API ，可以在程序代码中调用。比如 Linux 是 `fork()` 函数，Windows 是 `CreateProcess()` 函数。

## 线程

- 当进程执行程序指令时，实际上是由进程中的线程，在 CPU 中执行。

- 线程（Thread）是进程运行、CPU 调度的最小单位。
  - 每个进程可视作一个线程组，至少包含一个线程。其中第一个创建的线程称为主线程。

- 每个线程（称为父线程）可以创建任意个其它线程（称为子线程）。
  - 父线程及其所有子线程属于同一个进程。
    - 当父线程结束时，系统会自动杀死所有子线程。
    - 当一个进程中的所有线程都结束时，系统就会删除该进程的存在。
  - 每个线程也可以创建其它进程，不过此时看作是该线程所属的进程创建了其它进程，考虑的是进程间关系，而不是线程间关系。

- 操作系统给一个进程分配了系统资源之后，大部分会被该进程下的各个线程共享，包括：
  - PID、PPID
  - User ID 、Group ID
  - 内存，包括：
    - 虚拟内存空间，寻址相同
    - 堆区，包括静态变量、全局变量
  - 打开的文件描述符，比如 Socket
  - 环境变量，比如当前工作目录
  - 进程间通信的 signals 和 signal handlers

- 每个线程也有独自分配的系统资源，包括：
  - TID
  - CPU 调度
  - 栈区，比如局部变量
  - 寄存器

- Linux 系统上，用户可以调用 pthread.h 库的 `pthread_create()` 函数创建线程，不过实际创建的是轻量级进程（Light Weight Process，LWP）。
  - 每个进程可以创建多个 LWP ，它们之间共享系统资源，因此可以模拟线程。
  - 每个进程中，第一个创建的 LWP （即主线程）的 TID ，总是等于该进程的 PID 。

## 进程组

：Process Group ，包含一个或多个具有父子关系的进程。
- 每个进程组中有且仅有一个 Leader 进程，是其它进程的父进程。

## 进程会话

：Session ，包含一个或多个具有父子关系的进程组。
- 一个 Session 中有且仅有一个 Leader 进程，是其它进程、进程组的根父进程。
- 会话中的进程组又称为 job ，用于完成某种任务。
- 当 Session Leader 终止时，系统会给该 Session 的所有进程发送 SIGHUP 信号来终止它们。当 Session 中的所有进程都终止时，该 Session 就宣告消失。
- 例如：用户登录时会创建一个 login shell ，还会创建一个 Session ，以 login shell 作为 Session Leader 。
  - 在该 Session 中，只有一个进程组能工作在前台，其它进程组都只能工作在后台。
  - 当用户登出时，属于该 Session 的所有进程组都会被系统终止。

## 进程的信息

### 运行方式

- 前台进程
  - ：绑定到当前终端的 stdin ，因此会阻塞当前终端。
  - 普通方式启动的进程默认会绑定到当前终端的 stdin、stdout、stderr 。
- 后台进程
  - ：没有绑定到终端的 stdin ，但可能绑定了 stdout、stderr 。
  - 前台进程、后台进程都是当前终端的子进程。如果用户关闭当前终端，系统就会给这些进程发送 SIGNUP 信号，终止它们。
- 守护进程（daemon）
  - ：一种特殊的后台进程。运行在一个独立的 Session 中，完全脱离用户的终端，不会收到 SIGNUP 信号。
  - 系统服务程序通常以守护进程的方式运行。

### ID

Linux 系统会给每个进程、线程分配一个标识符（ID），包括：
- PID ：进程的 ID ，在整个系统中唯一。
- PPID ：父进程的 ID 。
- TID ：线程的 ID ，在其线程组中唯一。
- PGID ：进程组（Process Group）的 ID ，等于主进程的 ID 。
- TGID ：线程组（Thread Group）的 ID ，等于主线程的 ID 。
- SID ：Session 的 ID ，等于其 Leader 进程的 PID 。

### 标志符

- s ：该进程是 Session Leader 。
- \+ ：该进程属于前台进程。
- < ：high-priority (not nice to other users)。
- N ：low-priority (nice to other users)。
- L ：已锁定内存中的 page 。
- l ：是多线程的（使用 CLONE_THREAD）。

### 运行状态

- R ：Running
  - 进程处于 Running 状态时才会占用 CPU 。
- S ：Sleeping
  - 此时进程处于可中断的睡眠状态，被 CPU 挂起，等到某一时刻或满足某些条件时再继续运
  - 例如，HTTP 服务器通常一直处于 Sleeping 状态，收到 HTTP 请求时才有一瞬间切换到 Running 状态。
- D ：Disk Sleep
  - 此时进程处于不可中断的睡眠状态，不会响应异步信号，因此不能被 kill -9 杀死。
  - 例如，进程等待磁盘 IO 时，会进入短暂的 D 状态。
- I ：Idle ，即空闲状态。
- Z ：Zombie
  - 僵尸进程已经运行结束，但进程描述符还存在，说明父进程还没有回收它的资源。
  - 如果父进程没有正确回收子进程，还不断创建子进程，就会占用越来越多的系统资源。即使这些子进程自己运行结束了，变成僵尸进程，也可能耗尽系统的 PID ，导致系统不能创建新进程。
  - 如果父进程运行结束，init 进程会自动回收它的所有子进程。
- T ：Stopped ，暂停状态。
- t ：Traced ，比如进程被断点调试时处于被跟踪状态。
- X ：进程正在终止，这是一个很短暂的状态。

## 进程间通信

Linux 系统上，进程间通信（Inter Process Communication ，IPC）的主要方式如下：

### 信号

- 信号（signal）可能来源于硬件（比如键盘信号），也可能来源于软件（比如用 kill 命令）。信号产生后，会被内核发送给进程，相当于软件层的模拟中断。
- Linux 定义了多种信号，常见的如下：

    编号|宏定义名|默认动作
    -|-|-
    1  | SIGHUP  | 终止进程
    2  | SIGINT  | 终止进程
    3  | SIGQUIT | 终止进程
    9  | SIGKILL | 终止进程
    10 | SIGUSR1 | 终止进程
    12 | SIGUSR2 | 终止进程
    15 | SIGTERM | 终止进程
    19 | SIGSTOP | 暂停进程

    - 在不同的平台上，信号的编号可能有差异，因此最好通过宏定义名来指定信号。
    - SIGINT 通常由键盘中断（Ctrl+C）引发。
    - 向某个进程发出一个普通的终止信号时，进程可能立即终止，也可能做完清理工作之后再终止（比如释放占用的资源），甚至不终止。
    - SIGKILL、SIGSTOP 两种信号不能被进程忽略或捕捉，因此一定会立即执行。
    - SIGUSR1、SIGUSR2 两种信号常用于被用户绑定自定义的信号处理函数。
      - SIGUSR1 的默认动作是终止进程，不过 Apache、Nginx 等很多程序收到 SIGUSR1 信号之后会进行复位操作，比如刷新缓存、重新加载配置文件、重新打开日志文件，接近于重启进程。

- 相关的内核 API ：
  ```c
  #include <signal.h>

  int kill(pid_t pid, int sig);   // 向进程发送信号，发送成功则返回 0
  ```
  - pid
    - 如果为正数，则选中指定 PID 的进程。
    - 如果为 0 ，则选中当前进程组，即组内的所有进程。
    - 如果为 -1 ，则选中当前进程有权限发送信号的所有进程。
    - 如果为小于 -1 的负数，比如 -n ，则选中 PID 为 n 的进程的进程组。
    - 特别地，内核只支持将已注册 handler 的信号发送给 PID 为 1 的进程（通常是 init、systemd 等），会忽略 SIGKILL、SIGSTOP 等信号，避免系统崩溃。不过此时调用 kill() 依然会返回 0 。
  - sig
    - 可以填 int 值，也可以填 SIGTERM 等宏定义名。
    - 如果为 0 ，则不发送信号，但依然会检测目标进程是否存在、是否有权限发送信号。

- 当进程收到一个信号时，有三种处理方式：
  - 执行信号的默认动作
  - 忽略信号
  - 捕捉信号：进程将自己的信号处理函数传给内核，与一个信号绑定。当该信号发生时，内核就会执行该函数，从而实现该进程自定义的动作。如下：
    ```c
    #include <stdio.h>
    #include <signal.h>

    static void sig_handle(int sig_no)              // 定义信号处理函数
    {
        if(sig_no == SIGUSR1)
            printf("Received SIGUSR1\n");
        else
            printf("Received signal %d\n", sig_no);
    }

    int main(void){
        if(signal(SIGUSR1, sig_handle) == SIG_ERR)  // 绑定信号处理函数
            printf("Can not catch SIGUSR1\n");      // 如果不能绑定即不能捕捉，则报错
        return 0;
    }
    ```

### 信号量

- ：semophore ，一个非负整数，用于记录某个资源的可用数量。为 0 时表示资源不可用。

### 套接字

- ：Socket

### 管道文件

- 进程可以创建一个管道文件（pipe），和另一个进程同时连接到它，从中读写数据。
- 采用半双工通信，当一个进程写数据时，另一个进程只能读数据。
- 匿名管道（PIPE）：保存在内存中，没有文件描述符，只能用于父子进程之间的通信。比如管道符 | 。
- 命名管道（FIFO）：保存为文件系统中的一个文件，常用于两个独立进程之间的通信。

### 消息队列

- ：message queue ，一个链表结构，允许多个进程从中读写数据。

### 共享内存

- ：shared memory ，一块内存空间，允许多个进程同时访问，读写速度很快。
- 共享内存由内核创建，进程可以把它映射到自己的私有地址空间，从而访问它。
- 当多个进程同时访问共享内存时，需要采取一些措施保证线程之间的同步。
