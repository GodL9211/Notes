# 进程通信

Linux 系统上，进程间通信（Inter Process Communication ，IPC）的主要方式如下：

## 信号

- 信号（signal）可能来源于硬件（比如键盘信号），也可能来源于软件（比如用 kill 命令）。信号产生后，会被内核发送给进程，相当于软件层的模拟中断。
- Linux 定义了多种信号，常见的如下：

    编号|宏定义名|默认动作
    -|-|-
    1  | SIGHUP  | 终止进程
    2  | SIGINT  | 终止进程
    3  | SIGQUIT | 终止进程
    9  | SIGKILL | 终止进程
    10 | SIGUSR1 | 终止进程
    12 | SIGUSR2 | 终止进程
    15 | SIGTERM | 终止进程
    17 | SIGCHLD | 表示子进程终止，默认无动作
    19 | SIGSTOP | 暂停进程

    - 在不同的平台上，信号的编号可能有差异，因此最好通过宏定义名来指定信号。
    - SIGINT 通常由键盘中断（Ctrl+C）引发。
    - 向某个进程发出一个普通的终止信号时，进程可能立即终止，也可能做完清理工作之后再终止（比如释放占用的资源），甚至不终止。
    - SIGKILL、SIGSTOP 两种信号不能被进程忽略或捕捉，因此一定会立即执行。
    - SIGUSR1、SIGUSR2 两种信号常用于被用户绑定自定义的信号处理函数。
      - SIGUSR1 的默认动作是终止进程，不过 Apache、Nginx 等很多程序收到 SIGUSR1 信号之后会进行复位操作，比如刷新缓存、重新加载配置文件、重新打开日志文件，接近于重启进程。

- 相关 API ：
  ```c
  #include <signal.h>

  int kill(pid_t pid, int sig);   // 向进程发送信号，发送成功则返回 0
  ```
  - pid
    - 如果为 n > 0 ，则选中 PID 等于 n 的进程。
    - 如果为 0 ，则选中当前进程组的所有进程。
    - 如果为 -1 ，则选中当前进程有权限发送信号的所有进程。
    - 如果为 -n < -1 ，则选中 PGID 等于 n 的进程组中的所有进程。
    - 特别地，内核只支持将已注册 handler 的信号发送给 PID 为 1 的进程（通常是 init、systemd 等），会忽略 SIGKILL、SIGSTOP 等信号，避免系统崩溃。不过此时调用 kill() 依然会返回 0 。
  - sig
    - 可以填 int 值，也可以填 SIGTERM 等宏定义名。
    - 如果为 0 ，则不发送信号，但依然会检测目标进程是否存在、是否有权限发送信号。

- 当进程收到一个信号时，有三种处理方式：
  - 执行信号的默认动作
  - 忽略信号
  - 捕捉信号：进程将自己的信号处理函数传给内核，与一个信号绑定。当该信号发生时，内核就会执行该函数，从而实现该进程自定义的动作。如下：
    ```c
    #include <stdio.h>
    #include <signal.h>

    static void sig_handle(int sig_no)              // 定义信号处理函数
    {
        if(sig_no == SIGUSR1)
            printf("Received SIGUSR1\n");
        else
            printf("Received signal %d\n", sig_no);
    }

    int main(void){
        if(signal(SIGUSR1, sig_handle) == SIG_ERR)  // 绑定信号处理函数
            printf("Can not catch SIGUSR1\n");      // 如果不能绑定即不能捕捉，则报错
        return 0;
    }
    ```

## 信号量

- ：semophore ，一个非负整数，用于记录某个资源的可用数量。为 0 时表示资源不可用。

## 套接字

- ：[Socket](../网络/Socket.md)

## 管道文件

- 进程可以创建一个管道文件（pipe），和另一个进程同时连接到它，从中读写数据。
- 采用半双工通信，当一个进程写数据时，另一个进程只能读数据。
- 匿名管道（PIPE）：保存在内存中，没有文件描述符，只能用于父子进程之间的通信。比如管道符 | 。
- 命名管道（FIFO）：保存为文件系统中的一个文件，常用于两个独立进程之间的通信。

## 消息队列

- ：message queue ，一个链表结构，允许多个进程从中读写数据。

## 共享内存

- ：shared memory ，一块内存空间，允许多个进程同时访问，读写速度很快。
- 共享内存由内核创建，进程可以把它映射到自己的虚拟内存空间，从而访问它。
  - 当多个进程同时访问共享内存时，可能产生冲突。
- 所有 tmpfs 类型的文件系统，挂载的内存空间都属于共享内存，比如 `/run`、`/dev/shm` 。
  - `/dev` 目录属于 devtmpfs 文件系统，但该目录下的存储空间也属于共享内存。
