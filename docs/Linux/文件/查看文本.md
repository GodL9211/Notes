# 查看文本

有多种命令可以查看文件的内容。
- 有的文件是采用二进制格式存储的，不能直接阅读。
- 有的文件是采用 ASCII 码等编码格式存储的，称为文本文件，可以直接阅读。
  - 如果查看文本文件时出现乱码，说明解码时使用的编码格式不对。

> 本文中，大部分命令的输入参数都声明为 [file] 。如果不指定文件参数 file ，或者指定 - 作为 file ，该命令就会读取 stdin 作为输入。例如：ps | wc -l

## 查看文本

### cat

```sh
$ cat [file]    # 显示文件的内容
      -n        # 同时显示行号
      -b        # 空白行不记行号
      -E        # 在每行的末尾显示$
      -T        # 将 Tab 符显示成^I
      -v        # 显示不会 print 的特殊字符
```
- 不适合查看内容较多的文件，否则会显示好几页终端。
- 例：
    ```sh
    cat f1 > f2  # 拷贝文件 f1 的内容到文件 f2 中（相当于只 cp 内容）
    ```

### tac

```sh
$ tac [file]     # 从最后一行开始倒序显示文件的内容（与 cat 命令相反）
```

### head

```sh
$ head [file]    # 显示文件开头的 10 行
       -n n      # 显示开头的 n 行
       -c n      # 显示开头的 n 个字节（可以使用单位 K、M、G、T 等）
```
- 例：
    ```sh
    head -c 10M /dev/urandom > f1   # 生成一个指定大小、随机内容的文件
    ```

### tail

```sh
$ tail [file]    # 显示文件末尾的 10 行
       -n n      # 显示末尾的 n 行
       -c n      # 显示末尾的 n 个字节
       -f n      # 跟踪显示文件的末尾，当末尾增加内容时就显示出来（这会阻塞前台）
```

### more

```sh
$ more <file>    # 打开阅读器，显示文件的全部内容（只能向前翻页）
```

### less

```sh
$ less <file>    # 打开阅读器，显示文件的全部内容（可以前后翻页、查找）
       -N        # 显示行号
```
- 该阅读器的控制方法与 vim 相似，只是要按 q 键退出。

### diff

```sh
$ diff <file1> <file2>    # 逐行比较两个文件的差异（如果没有差异，则显示为空）
       -q                 # 安静模式，如果有差异，则只显示一句提示，并不显示具体差异
```
- 例：
    ```sh
    cat f1 | diff -q f2 -    # 通过 stdin 传入一个文件进行比较
    ```

## 筛选文本

### grep

```sh
$ grep <pattern> [file]...  # 在文件中筛选匹配 pattern 的每行文本
       -i                   # 忽略大小写
       -c                   # 只显示匹配的行数
       -n                   # 同时显示行号
       -r                   # 递归检索指定目录下的所有文件
       -v                   # 反向筛选
       [-e pattern]...      # 指定多个 pattern ，只要文本匹配任一 pattern 就会被筛选出来
```
- pattern 支持基本的正则语法。
- 例：
    ```sh
    grep -n root /etc/passwd                    # 普通的 pattern
    grep -n '^root.*' /etc/passwd               # 正则语法的 pattern
    grep -cr 'DEBUG' . | grep -v :0             # 递归检索指定目录下的所有文件
    find . -name "*.py" | xargs grep -c 'DEBUG' # 先找出一组文件，再筛选文本
    grep README.md -e 'hello' -e 'world'        # 指定多个 pattern
    ```

### wc

```sh
$ wc [file]... 
     -l        # 统计行数
     -c        # 统计字节数
     -m        # 统计字符数
```

### cut

```sh
$ cut [file]...
      -f 1 -d ","    # 显示每行的第一个字段，以 , 作为字段分隔符
      -b "1 2 3"     # 显示每行的第几个字符
```

### awk

```sh
$ awk [option] [expression] [file]...
      '{print $3}'             # 显示每行的第 3 个字段
      '{print NR, $(NF-1)}'    # 显示每行的行号、倒数第二个字段
      -F ','                   # 设置字段分隔符（默认是一个或多个空格、Tab）
```
- awk 的表达式要用单引号包住，避免转义。
- 可以设置在某种条件下才进行显示：
    ```
    'root {print $3}'          # 要求当前行包含指定内容
    'NR>3 {print $3}'          # 要求当前行数大于 3
    '$1=="root" {print $3}'    # 要求第一个字段等于指定字符串
    ```
- $0 表示整行，$1 表示每行的第一个字段，以此类推。当 $n 超过当前行的最大字段数时，显示就为空。
- awk 的内置变量：
    - NF ：当前行的最大字段数
    - NR ：当前行数

## 文本排版

### column

```sh
$ column [file]...
         -t          # 将文本转换成一个列表输出
         -s " "      # 指定分割输入文本的字段分隔符
         -o "  "     # 指定分割输出列表的字段分隔符（默认是两个空格）
```
- 例：
    ```sh
    [root@Centos ~]# echo $PATH 
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    [root@Centos ~]# echo $PATH | column -t -s :
    /usr/local/sbin  /usr/local/bin  /usr/sbin  /usr/bin  /sbin  /bin
    [root@Centos ~]# echo $PATH | column -t -s : -o ', '
    /usr/local/sbin, /usr/local/bin, /usr/sbin, /usr/bin, /sbin, /bin
    ```

### sort

```sh
$ sort [file]...    # 将文本的每行排序之后输出
       -k 1         # 按每行的第 1 个字段进行排序
       -t " "       # 指定每行的字段分隔符
       -r           # 反序排列
```
- 例：
    ```sh
    [root@Centos ~]# ls -al | sort -k 9
    total 216
    dr-xr-x---. 22 root root  4096 Dec  6 15:54 .
    dr-xr-xr-x. 19 root root  4096 Dec  9 10:00 ..
    -rw-------   1 root root 41827 Dec  9 09:59 .bash_history
    -rw-r--r--.  1 root root    18 Dec 29  2013 .bash_logout
    -rw-r--r--.  1 root root   176 Dec 29  2013 .bash_profile
    ```
