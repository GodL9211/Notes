# 处理文本

有多种命令可以查看文件的内容。
- 有的文件是采用二进制格式存储的，不能直接阅读，可能要用专门的软件来解码。
- 有的文件是采用ASCII码等编码格式存储的，称为文本文件，可以直接阅读。
  - 如果查看文本文件时出现乱码，说明解码时使用的编码格式不对。

> 本文中，大部分命令的输入参数都声明为 [file] 。如果不指定文件参数file，或者指定 - 作为file，该命令就会读取stdin作为输入。例如：ps | wc -l

## 查看文件内容

命令：

```shell
$ cat [file]    # 显示文件的内容
      -n        # 同时显示行号
      -b        # 空白行不记行号
      -E        # 在每行的末尾显示$
      -T        # 将Tab符显示成^I
      -v        # 显示不会print的特殊字符
```
- 不适合查看内容较多的文件，否则会显示好几页终端。
- 例：
    ```shell
    cat f1 > f2  # 拷贝文件f1的内容到文件f2中（相当于只cp内容）
    ```

```shell
$ tac [file]     # 从最后一行开始倒序显示文件的内容（与cat命令相反）
```

```shell
$ head [file]    # 显示文件开头的10行
       -n n      # 显示开头的n行
       -c n      # 显示开头的n个字节（可以使用单位 K、M、G、T 等）
```
- 例：
    ```shell
    head -c 10M /dev/urandom > f1   # 生成一个指定大小、随机内容的文件
    ```

```shell
$ tail [file]    # 显示文件末尾的10行
       -n n      # 显示末尾的n行
       -c n      # 显示末尾的n个字节
       -f n      # 跟踪显示文件的末尾，当末尾增加内容时就显示出来（这会阻塞前台）
```

```shell
$ more <file>    # 打开阅读器，显示文件的全部内容（只能向前翻页）
```

```shell
$ less <file>    # 打开阅读器，显示文件的全部内容（可以前后翻页、查找）
       -N        # 显示行号
```
- 该阅读器的控制方法与 vim 相似，只是要按 q 键退出。

```shell
$ diff <file1> <file2>    # 逐行比较两个文件的差异（如果没有差异，则显示为空）
       -q                 # 安静模式，如果有差异，则只显示一句提示，并不显示具体差异
```
- 例：
    ```shell
    cat f1 | diff -q f2 -    # 通过stdin传入一个文件进行比较
    ```

## 筛选文本

命令：

```shell
$ grep <pattern> [file]...  # 在文件中筛选匹配pattern的每行文本
       -c                   # 只显示匹配的行数
       -v                   # 反向筛选不匹配pattern的每行文本
       -r                   # 递归在当前目录下的所有文件中检索
       -i                   # 忽略大小写
       -n                   # 同时显示行号
```
- 例：
    ```shell
    grep -in root /etc/passwd
    grep -cr DEBUG | grep -v :0    # 递归在当前目录下的所有文件中查找某个关键词
    find . -name "*.py" | xargs grep -c DEBUG
    ```

```shell
$ wc [file]... 
     -l        # 统计行数
     -c        # 统计字节数
     -m        # 统计字符数
```

```shell
$ cut [file]...
      -f 1 -d ","    # 显示每行的第一个字段，以 , 作为字段分隔符
      -b "1 2 3"     # 显示每行的第几个字符
```

```shell
$ awk [option] [expression] [file]...
      '{print $3}'             # 显示每行的第3个字段
      '{print NR, $(NF-1)}'    # 显示每行的行号、倒数第二个字段
      -F ','                   # 设置字段分隔符（默认是一个或多个空格、Tab）
```
- awk的表达式要用单引号包住，避免转义。
- 可以设置在某种条件下才进行显示：
    ```
    'root {print $3}'          # 要求当前行包含指定内容
    'NR>3 {print $3}'          # 要求当前行数大于3
    '$1=="root" {print $3}'    # 要求第一个字段等于指定字符串
    ```
- $0 表示整行，$1 表示每行的第一个字段，以此类推。当 $n 超过当前行的最大字段数时，显示就为空。
- awk的内置变量：
    - NF：当前行的最大字段数
    - NR：当前行数

## 文本排版

```shell
$ column [file]...
         -t          # 将文本转换成一个列表输出
         -s " "      # 指定分割输入文本的字段分隔符
         -o "  "     # 指定分割输出列表的字段分隔符（默认是两个空格）
```
- 例：
    ```shell
    [root@Centos ~]# echo $PATH 
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    [root@Centos ~]# echo $PATH | column -t -s :
    /usr/local/sbin  /usr/local/bin  /usr/sbin  /usr/bin  /sbin  /bin
    [root@Centos ~]# echo $PATH | column -t -s : -o ', '
    /usr/local/sbin, /usr/local/bin, /usr/sbin, /usr/bin, /sbin, /bin
    ```

```shell
$ sort [file]...    # 将文本的每行排序之后输出
       -k 1         # 按每行的第 1 个字段进行排序
       -t " "       # 指定每行的字段分隔符
       -r           # 反序排列
```
- 例：
    ```shell
    [root@Centos ~]# ls -al | sort -k 9
    total 216
    dr-xr-x---. 22 root root  4096 Dec  6 15:54 .
    dr-xr-xr-x. 19 root root  4096 Dec  9 10:00 ..
    -rw-------   1 root root 41827 Dec  9 09:59 .bash_history
    -rw-r--r--.  1 root root    18 Dec 29  2013 .bash_logout
    -rw-r--r--.  1 root root   176 Dec 29  2013 .bash_profile
    ```

## 修改文本

命令：

```shell
$ tr <源字符集> <目标字符集>  # 替换文本中的指定字符
     -c                      # 反选源字符集（即选中其它字符）
     -d                      # 删除源字符集
```
- tr命令的输入不是文件，只能是stdin，且输出到stdout。
- 例：
    ```shell
    cat f1 | tr a-z A-Z    # 将小写字母换成大写字母
    cat /dev/urandom | tr -cd A-Za-z0-9 | head -c 12 ; echo  # 生成随机密码
    ```

```shell
$ sed [表达式] [file]...
      -i                         # 将修改结果保存到源文件（默认将修改结果输出到stdout）
      '10a hello'                # 在文件的第10行之后插入一行字符串
      '10,$d'                    # 删除文件的第10行到最后一行
      '/hello/d'                 # 找到包含hello的所有行并删除
      's/源字符串/目标字符串/g'   # 替换字符串
```
- 例：
    ```shell
    cat f1 | sed 's/hello//g' > f2  # 将修改结果保存到另一个文件
    sed -i 's/hello//g' f1          # 将修改结果保存到源文件
    ```

## vi/vim 

vi 是类Unix系统的内置文本编辑器，而 vim 是最流行的类 vi 编辑器。

- nano：一个非常简单的文本编辑器，执行命令 nano 即可进入。

## 打开编辑器

执行以下命令即可打开 vim 编辑器：
```shell
$ vim [path]
```
- 如果不指定path，则打开一个空的编辑器。
- 如果指定的path是一个文件，则对它进行编辑；如果该文件不存在，则可以在保存时创建它。
- 如果指定的path是一个目录，则可以管理该目录下的文件。
- vim 的命令支持组合，可以连续输入多条命令，组合它们的功能。

用vi/vim打开一个文件时，会在其目录下生成一个缓存文件，缓存文件的最后修改状态，命名格式为 .{filename}.swp 。
- 如果正常退出vi/vim，或者异常退出vi/vim但并没有修改文件的内容，该缓存文件就会被自动删除。
- 如果目录下存在该缓存文件，则可能是因为：
    - 此时有其他人正在用vi/vim操作该文件。
    - 上一次异常退出vi/vim且修改了文件的内容，建议执行以下命令：
        ```shell
        vim -r .{filename}.swp  # 恢复到文件的最后修改状态
        :wq                     # 保存文件
        rm -f .{filename}.swp   # 删除缓存文件
        ```

### 使用编辑器

刚启动 vim 时默认进入命令模式，输入 : 则进入底线命令模式，在其它模式下按Esc键则退出到命令模式。

命令模式（Command mode）
- 此时不能编辑文本，只能输入某些字符作为命令（区分大小写）。
- 文本末尾显示的 ~ 表示空行，并不实际存在。
- vim 的命令支持组合，可以连续输入多条命令，组合它们的功能。
- 常用命令：
    - i/a ：进入插入模式
    - o ：在光标下方插入一行并进入插入模式
    - r ：替换光标所在的那个字符
    - R ：进入替换模式
    - 关于翻页
        - PageUp/PageDown：上下翻页
        - 按下Space键则将光标后移一格，输入一个数字n再按Space键则将光标后移n格
        - 按下Enter键则将光标下移一行，输入一个数字n再按Enter键则将光标后移n行
        - 按下gg会移动到第一行，按下G则移动到最后一行
    - 输入 /word（或 ?word ）则向下（或向上）查找word字符串，输入n（或N）换到下一个（或上一个）匹配结果
    - u ：撤销上一次操作
    - Ctrl+r ：重做被撤销的操作
    - . ：重做上一次操作（对u和Ctrl+r无效）
    - yy ：复制光标所在的那行（输入数字加yy是复制n行）
    - x/X ：删除光标之后（或之前）的一个字符（输入数字加x/X是删除n个）
    - dd ：剪贴光标所在的那行（输入数字加dd是删除n行）
    - p/P ：粘贴到光标的下一行（或上一行）
    - v ：开始选中，此时光标移动过的区域都会被反白选中，再按一下d或y即可删除或复制
    - Ctrl+v ：开始矩形选中

底线命令模式（Last line mode）：此时输入的字符会显示在下方的命令行中。
- 常用命令：
    - `:wq` ：保存并退出（输入w表示保存，输入q表示退出）
    - `:wq!` ：强制保存再退出（输入!表示强制执行操作）
    - `:wq [文件名]` ：保存为指定文件
    - `/str` ：向下查找字符串，按n或N可以重复上一次查找或退回到上一次查找的位置
    - `?str` ：向上查找字符串
    - `:s/源字符串/目标字符串/g` ：替换字符串（目标字符串为空的话就是删除）

可以将vim的配置永久保存在 ~/.vimrc 文件中。
- 例：
    ```
    set nu              # 显示行号（number）
    set encoding=utf-8  # 设置编码格式
    set ignorecase      # 搜索时不区分大小写
    ```
