# 其它功能

保存在MySQL的 datadir 目录下

## binlog

：用于记录MySQL执行的所有写操作，以事务为单位。
- 常用于拷贝数据、备份数据。
- MySQL可能在 datadir 目录下保存多个binlog文件，每个文件中记录多个事务，每个事务的起始地址称为position。
- 每个binlog文件默认最小为 4096 Bytes、最大为 1 GB。但是一个事务总是会整个写入一个binlog文件中，因此binlog文件可能超过最大大小。

binlog有三种记录形式：
- statement
  - ：记录MySQL执行的每条写操作的SQL语句.
  - 优点：日志量较少。
  - 缺点：还原数据时，SQL语句的执行结果不一定与原来一致。比如重复执行`update tb1 set datetime=now() where id=1;`时，now()函数的返回值不同。
- row
  - ：记录MySQL对每行数据做出的修改。
  - 优点：还原数据时，能保证与原来的数据一致。
  - 缺点：日志量较多。
- mixed
  - ：一般的操作用statement方式记录，状态可能变化的操作用row方式记录。

### 相关配置

```ini
[mysqld]
log-bin=mysql-bin       # 启用binlog，并设置binlog文件的前缀名
sync_binlog=1           # 每执行几次事务就保存一次binlog（默认值为0，由文件系统自动刷新缓存）
binlog_format=mixed
expire_logs_days=7      # binlog的过期天数（默认为0，过期后会被自动删除）

# binlog-do-db=db1      # 记录该数据库（其它的默认不记录）
# binlog-do-db=db2
# binlog-ignore-db=db1  # 不记录该数据库（其它的默认记录）
# binlog-ignore-db=db2
```

### 相关命令

- 显示binlog的配置：
    ```
    mysql> show variables like '%log_bin%';
    +---------------------------------+--------------------------------+
    | Variable_name                   | Value                          |
    +---------------------------------+--------------------------------+
    | log_bin                         | ON                             |
    | log_bin_basename                | /var/lib/mysql/mysql-bin       |
    | log_bin_index                   | /var/lib/mysql/mysql-bin.index |
    | log_bin_trust_function_creators | OFF                            |
    | log_bin_use_v1_row_events       | OFF                            |
    | sql_log_bin                     | ON                             |
    +---------------------------------+--------------------------------+
    ```

- 显示已有的所有binlog文件：
    ```
    mysql> show binary logs;
    +------------------+-----------+
    | Log_name         | File_size |
    +------------------+-----------+
    | mysql-bin.000001 |       177 |
    | mysql-bin.000002 |   2922996 |
    | mysql-bin.000003 |       746 |
    +------------------+-----------+
    ```

- 其它命令：
    ```
    show master status\G;                       # 显示master的状态（只包括binlog状态）
    show binlog events in 'mysql-bin.000001';   # 显示一个binlog的内容
    show binlog events in 'mysql-bin.000001' FROM 0 limit 2;    # 显示从pos=0开始的最多2个事务

    reset master;                               # 删除所有binlog，重新开始记录
    purge master logs to 'mysql-bin.000003';    # 删除指定的binlog
    ```

- 在shell中，可以用官方提供的mysqlbinlog命令解析binlog的内容。如下：
    ```shell
    mysqlbinlog mysql-bin.000001
                --start-position=0
                --stop-position=177
                --start-datetime="2019-12-01 12:00:00"
                --stop-datetime="2019-12-02 12:00:00"
                --database=db1      # 只显示指定数据库的记录
    ```

- 将binlog转换成.sql文件之后，便可以导入数据库，还原数据。如下：
    ```shell
    mysqlbinlog mysql-bin.000001 > backup_1.sql 
    mysql -u root -p < backup_1.sql 
    ```

## mysqladmin
mysqladmin命令用于管理mysql服务器

mysqladmin create [db]      # 创建一个datebase
drop [db]        # 删除一个datebase及其tables
kill [id]...      # 终止一个mysql线程
status          # 查看mysql服务器的状态
-u <用户名> password  # 为一个用户设置新密码
shutdown        # 关闭mysql服务器

## 数据库引擎

- MyISAM：传统的默认引擎。不支持外键，不支持事务。
- InnoDB：从MySQL5.5开始成为默认引擎，支持外键，支持事务，能通过行级锁实现事务的ACID。
  - 一般采用InnoDB引擎。
  - 默认每执行一条SQL语句就会作为一个事务提交，永久更改数据库的状态。可以用SET AUTOCOMMIT=0取消自动提交。
  - 可以把连续的多个语句声明为一个事务，如下：
BEGIN;        # 开始事务

ROLLBACK;      # 回滚到BEGIN时的状态
SAVEPOINT p1;    # 声明一个回滚点
ROLLBACK TO p1;    # 回滚到指定时候

COMMIT;        # 提交事务（在此之前不会自动提交）

## 备份数据

### 导出数据库

- 在主机的终端中，使用mysqldump工具导出为sql脚本：
mysqldump -u <用户名> -p -A > dump.sql            # 导出所有数据库
mysqldump -u <用户名> -p -B <数据库名> > dump.sql      # 导出指定数据库
mysqldump -u <用户名> -p -B <数据库名> <表名> > dump.sql    # 导出指定数据库中的指定表
  - sql脚本包含了重新创建该数据库需要使用的命令。
- 在mysql客户端的命令行中，使用outfile命令导出为文本文件：
select * from tb1 into outfile "/var/lib/mysql-files/tb1"
fields terminated by "," enclosed by '"'    # 这里调整输出格式为csv
lines terminated by '\n';
  - mysql服务器限制了导出目录，可使用show variables like "secure_file_priv";查看。

### 导入数据库

- 在主机的终端中，可以直接导入sql脚本：
mysql -u <用户名> -p < /home/dump.sql
  - 也可以在mysql客户端的命令行中导入sql脚本：
source /home/dump.sql
- 在mysql客户端的命令行中，使用load data infile命令导入文本文件：
load data infile "/var/lib/mysql-files/tb1" into table tb1
fields terminated by "," enclosed by '"'    # 这里调整输入格式为csv
lines terminated by '\n';
  - 默认是导入mysql服务器上的文件，改成load data loca infile就是导入mysql客户端上的文件。


## 管理用户的账号。
- 数据库"mysql"存储了mysql服务器的配置信息，其中的数据表"user"存储了所有mysql用户的信息。
select * from mysql.user;        # 获取所有用户的信息

create user "user1"@"127.0.0.1";    # 创建用户user1，只允许从该IP地址登录，不需要输入密码
create user "user1"@"%" identified by "aaa";  # 创建用户，允许从任何IP地址登录，密码是aaa

set password for "user1"@"127.0.0.1" = password("123456");  # 修改密码（用password()函数会加密）
update mysql.user set password=password("bbb") where user="user1";

drop user "user1"@"127.0.0.1";    # 删除用户
delete from mysql.user where user="user1";

- MySQL5.7开始，mysql.user表的 password 字段被改为了 authentication_string 字段，因此要用以下语句修改密码：
```
update mysql.user set authentication_string=password('******') where user='user1';
```
- 管理用户的权限。
show grants;              # 查看当前用户的权限
show grants for "user1"@"%";      # 查看指定用户的权限

MySQL的权限划分比较细，可以细分用户对数据库、数据表的权限。

# 授予用户在数据库db1中创建、修改、删除数据表的权限
grant create,alter,drop on db1.* to "user1"@"%";

# 授予用户查询、修改、插入、删除数据库db1中所有数据表的权限
grant select,update,insert,delete on db1.* to "user1"@"%";

grant all privileges on db1 to "user1"@"%";  # 授予用户操纵数据库db1的全部权限
grant all on *.* to "root"@"localhost";    # 授予用户操纵所有数据库的全部权限

FLUSH PRIVILEGES;            # 刷新权限的设置（否则要等到mysql服务器重启时才会生效）

revoke all on *.* from "user1"@"%";  # 将grant、to改为revoke、from，就是撤销指定用户的权限


如果忘记了密码，可以关闭mysqld，然后用以下命令启动mysqld，修改密码，然后再按正常的方式启动mysqld。
```shell
mysqld --skip-grant-tables --skip-networking --user=mysql
       --skip-grant-tables  # 不开启身份认证
       --skip-networking    # 不开启网络功能
       --user=mysql         # 以mysql用户启动（mysqld默认不允许以root用户启动）
```

## 外键：让表1中的一个字段引用表2中的一个字段，从而让表1中的数据映射到表2中的数据。
- 建立外键的条件：
  - 表1中的外键字段的值在表2中都存在。
  - 表2中被引用的字段是unique的。
- 外键的关系。
  - 一对一：表1中的数据与表2中的数据一一对应。
  - 多对一：表1中的多条数据对应到表2中的一条数据。（此时，要在多的那方数据表中定义外键）
  - 多对多：表1中的多条数据对应到表2中的多条数据。（此时，可以在任意一方数据表中定义外键）
- 定义外键：
create table tb1(
    id int primary key auto_increment,      # 定义字段id，并声明为主键
    num int not null,              # 定义字段num
    foreign key(num) references tb2(id)    # 将字段num关联到tb2的主键
);

alter table tb1 add num int not null;      # 添加一个字段
alter table tb1 add constraint num foreign key(num) references tb2(id);  # 将该字段声明为外键

alter table tb1 drop foreign key num;      # 取消外键
  - 在tb1中写入一条包含外键的数据时，该外键值必须在tb2中存在，否则会报错。
  - 删除tb2之前，必须先删除tb1中关联到它的数据。

## 索引：基于数据表中的某些列建立一个有序表，使得以后查询这些列时会更快，而不必遍历全表。
- 如果在索引表中找到了匹配的数据，MySQL就能根据这条索引所映射的物理地址，直接读取完整列的原数据。
  - 如果在索引表中没有找到匹配的数据，MySQL依然会去遍历全表。
- MySQL在查询时使用索引的条件。
  - 如果使用where A = B进行查询，当字符串B包含单列索引的那个字段、或组合索引的第一个字段时，才会使用相匹配的索引。
另外，如果B没有加上双引号，可能会被MySQL当做其它数据类型处理，而不使用索引。比如where name=123就会被看作int类型。
  - 如果使用where A or B进行查询，
  - 如果使用where A like B进行查询，当字符串B是常量、且不以 % 开头时，才会使用相匹配的索引。
  - 如果MySQL判断出索引的效率比全表扫描更低，就不会使用索引。
- 可以主动控制MySQL是否使用索引：
explain select * from tb1 use index(index_name) where name="AA";      # 只使用某些索引
explain select * from tb1 ignore index(index_name) where name="AA";    # 忽略某些索引
explain select * from tb1 force index(index_name) where name="AA";    # 强制使用某些索引
## 单列索引：从单个列生成一个索引列。
- 在创建表时定义索引列：
create table tb1 (...,index index_name(name));    # 从列name生成索引列index_name
- 给已有的表添加索引列：
alter table tb1 add index index_name(name);
create index index_text on tb1(text(100));
  - 如果对text类型的列加索引，则要限制其长度。长度越短，越有利于索引的查询速度、减少存储空间。
- 查看表的索引列：
show index from tb1;
- 删除表的索引列：
alter table tb1 drop index index_name;
- 加上unique，就可以声明为列值唯一的索引（值可以为null）。
alter table tb1 add index index_name(name);
- 单列索引适合优化只考虑一个字段的查询语句，比如：where name="Leo"。
## 组合索引：由多个列组成一个索引列。
- 定义的方法与单列索引类似：
alter table tb1 add index name_age(name, age);
- 组合索引适合优化同时考虑多个字段的查询语句，比如：where name="Leo" and age>20。
- 一张表可以有多个单列索引、组合索引。
## 全文索引：用于处理大文本。
## 索引可以使查询速度更快。但每次修改数据时都要刷新索引表，导致insert、update、delete操作变慢。
- 适合使用索引的情况。
  - 表的主键就是一个唯一索引。
  - 经常在where子句中出现的字段。
  - 需要排序的列。
- 不适合使用索引的情况。
  - 数据量不是很多的表。（优化效果不明显）
  - 经常增删改的字段。
  - 取值容易重复的列。（此时MySQL会优先选择遍历全表）
## 在SQL语句之前加上explain关键字，会分析该查询过程。
 
- type：查询类型。效率从高到低依次为：
  - const  ：查询某个唯一的索引键，找到了就立即返回。比如唯一索引。
  - eq_ref  ：每个索引键只对应一行数据。比如唯一索引。
  - ref    ：每个索引键可能对应多行数据。
  - range  ：只检索索引表的某个范围。比如where...between、in、is null。
  - index  ：遍历了索引表。
  - all    ：遍历了全表，效率最低。
- possible_keys：该查询可能使用的索引。
- key    ：实际使用的索引。
- ref    ：使用了索引表的第几列。
- rows    ：找到目标数据需要读取的行数。


字符集
## 字符集。
- 创建数据库、数据表时，如果没有指定字符集、字符库，则默认使用server的字符集。
  - 字符集utf8：它不区分大小写。每个字符最多占3字节，不完全支持标准的utf-8字符（因为MySQL引入该字符集时，utf8标准尚未统一）。
它的默认字符序为utf8_general_ci。
  - 字符集utf8mb4：每个字符最多占4字节，完全支持标准的utf-8字符。
它的默认字符序为utf8mb4_unicode_ci。
  - 字符序utf8_bin：按二进制值存储每个字符，因此会区分大小写。
- MySQL中，数据库名、表名要区分大小写，而列名不区分大小写，输入的命令也不区分大小写。
  - 如果要让字段的内容区分大小写，可以采用字符序utf8_bin，也可以在搜索字段时加上关键字binary，从而区分大小写。如下：
select * from tb1 where binary name = "Aa";
- 查看当前数据库使用的字符集、字符序：
SELECT @@character_set_database, @@collation_database;
  - 设置数据库、数据表的字符集：
alter database <db> [default] character set utf8mb4    # 设置数据库（默认）使用的字符集
[[default] collate utf8_general_ci];      # 设置字符序
# 开头改为alter table <tb>，就是设置数据表的
# 也可改为create database <db>、create table <name>，在创建时就设置字符集
  - 设置列的字符集：
alter table <表名> add column <列名> varchar(25) character set utf8mb4;
  - 输入status，其显示内容中包括server、db、client使用的字符集。如果要永久修改这些配置，需要修改mysql的配置文件。



数据类型
## MySQL的数据类型。
- 整型
tinyint  ：存储时占1字节，取值范围为-128~127（带符号）。
smallint  ：2字节。
mediumint：3字节。
int    ：4字节。
bigint  ：8字节。
- 浮点型
float  ：4字节。
double  ：8字节。
decimal(m,d)：m是总位数，d是小数位数。
- 字符串
char(n)    ：固定占n字节（n<256)。如果存入的字符串长度小于n，则自动加上空格补全之后再存储。
varchar(n)  ：当n<256时，占n+1个字节；当n>=256时，占n+2个字节。最多占65535个字节。
text      ：以文本格式存储字符串（可以指定字符集），最多占65535个字节。
blob      ：以二进制格式存储字符串，最多占65535个字节。
- 时间
date      ：3字节，格式为“YYYY-MM-DD”。
time      ：3字节，格式为“HH:MM:SS”。
datetime    ：8字节，组合了date和time，格式为“YYYY-MM-DD HH:MM:SS”。
timestamp  ：4字节，自动存储修改的时间戳。
- 其它
json      ：MySQL5.7新增的数据类型，以类似数组对象的格式存储。


数据库锁
## 数据库锁：多个请求同时访问同一个数据时，要对数据加锁，避免产生冲突。操作完成之后再释放锁。
- 使用场景：
  - 如果当前请求是读取数据，其它请求也只是读取数据，则一般不需要加锁。
  - 如果当前请求是读取数据，其它请求可能修改数据，则应该加锁来保护当前请求。
  - 如果当前请求是修改数据，则应该加锁来保护其它请求。
## 根据严格程度分类。
- 共享锁：又称为只读锁，允许其它请求读取该数据，不允许修改。
- 排它锁：又称为独占锁，不允许其它请求读取、修改该数据。
## 根据控制范围分类。
- 行锁
- 表锁
## 根据使用策略分类。
- 悲观锁：每次读取、修改数据时都加锁。
  - 适用于经常修改数据的情况。
  - 通常使用数据库提供的锁机制。如下：
select * from tb1 where id = 1 for update;    # 用for update加锁
...
commit;                    # 提交事务
- 乐观锁：修改数据时才加锁。
  - 适用于很少修改数据的情况。
  - 数据库没有提供乐观锁，要通过编程实现。如下：
select age from tb1 where id = 1;        # 先查询下修改之前的值，这里假设age字段为10
update tb1 set age=11 where id=1 and age=10;  # 执行之后，根据返回值判断是否成功修改
# 可以专门使用一个timestap字段来判断数据是否被修改


