# 简介


- 线程间通信的常用方式：
  - 轮询（poll）：主线程循环去检查子线程的状态，这会浪费一些主线程的时间，
  - 回调（callback）：子线程执行结束后调用主线程的一个函数或方法。



## 创建子进程、子线程时，可以把它们设置成daemon，即后台运行。（此daemon不是指守护进程）
- Python创建的子进程、子线程默认是非daemon。
- 创建一个daemon之后，就不必考虑如何让它结束。
  - 当一个进程组中的所有非daemon进程结束时，系统会自动终止所有daemon线程，然后结束该进程组。
  - 当一个进程中的所有非daemon线程结束时，系统会自动终止所有daemon线程，然后结束该进程。

## 结束子线程的方法。（对子进程同理）
- 由主线程控制何时停止子线程。
  - 尽量不要强制杀死子进程，应该让它自己自愿结束，清理自己占用的资源。因为子线程可能正在执行一些不宜中断的操作，比如拿到了某个资源的锁、打开了某个文件还没有关闭、创建了孙线程还没有关闭。
  - 当主进程异常终止时（比如被kill -9），子进程就会变成没人管的孤儿进程。
- 把子线程设置成daemon，当主进程退出时它们就会被系统自动终止。
- 让子线程自己判断是否要结束运行。
  - 这样子线程的独立性强。
- 等子线程处理完所有业务，运行结束。
  - 这需要事先确定子线程不会无限运行。


## CPython早先引入了GIL（Global Interpreter Lock，全局解释锁）机制。
- 为了保证多线程之间不冲突，同一时间只有一个线程拿到GIL运行，当该线程暂时不用执行字节码时（比如等待IO响应时）就会把GIL传递给其它线程，或者隔一小段时间后解释器会抢走这个GIL给其它线程（这可能中断正在执行的某个任务，所以以防万一，还是要加锁来保证线程安全）。
- 由于GIL机制，CPython程序同时只能使用CPU的一个核。因此，处理IO密集型任务时，用多线程能提高效率；处理CPU密集型任务时，用多进程或协程才能提高效率。