# 身份认证

- 当服务器收到客户端的访问请求时，通常需要执行以下安全措施：
  - 身份认证 ：识别客户端的身份。如果是一个已注册的用户，则让该客户端进入登录状态，否则视作未登录。
  - 用户授权 ：当客户端登录成功之后，检查该用户的权限，判断允许访问哪些资源。
- 本文介绍多种身份认证的方式。

## 密码登录

：用户访问网站，输入用户名、密码进行登录。
- 为了避免密码被暴力破解，发现一个用户连续多次登录失败之后，通常禁止该用户登录一段时间。

## 凭证登录

：服务器通过凭证记录、验证用户的身份信息。
- 常见的几种凭证：
  - cookie
  - session
  - JWT
  - SSL 证书

### cookie

- 虽然 HTTP 通信是无状态的，但可以通过 cookie 或 session 保存 HTTP 通信的某些信息。
- 工作流程：
  1. Web 服务器将各个客户端的某些信息（比如用户名、凭证）保存在客户端的 cookie 文件中。
  2. 当客户端下一次发出 HTTP 请求时，可以在请求报文的 headers 中填入 cookie 数据，从而告知上一次 HTTP 通信的信息。
     - Web 浏览器访问某个网站时会自动使用、且仅使用该网站的 cookie ，将它填入请求报文的 headers 中。
- cookie 保存在客户端上，可能被泄露、篡改、盗用，是不安全的。因此服务器应该采取以下措施：
  - 如果数据不重要，可以直接存放到 cookie 中。比如客户端上一次 HTTP 通信的状态。
  - 如果数据是需要保密的，则加密后再存放到 cookie 中。
  - 如果数据是客户端的某种凭证，则要防止篡改、伪造。还要设置过期时间，过期之后服务器就不认。

### session

- 工作流程：
  1. Web 服务器将每个客户端的信息保存在服务器上，比如数据库、缓存中。只将 session id 发送给客户端，用于分辨客户端的身份。
  2. 客户端每次发出 HTTP 请求时，可以将 session id 放在 HTTP Header、body 或 URL 中，传给服务器。
  3. 服务器根据 session id 找到对应的 session ，载入该客户端的信息。
- 优点：
  - session 存储在服务器上，因此不怕泄露，可以包含敏感信息。
  - session 可以要设置过期时间，过期之后就删除。如果客户端再发送该 session id ，服务器不会认可。
- 缺点：
  - 将 session id 存储在客户端的 cookie 中，可能被 CSRF 攻击。

### JWT

：JSON Web Token ，一个实现凭证登录的 API 规范，将 JSON 格式的消息编码成 token 。
- JWT 的作用与 session 类似。相当于服务器将 session 的内容编码成 token ，发送给客户端。客户端每次发出 HTTP 请求时，可以带上该 token 。
- 优点：
  - 客户端可以将 token 存储在 cookie 中，也可以存储在内存或数据库中，这样还能防止 CSRF 攻击。
- 缺点：
  - 不能包含敏感信息。

#### 示例

1. 生成 header ：
    ```json
    {
      "typ": "JWT",
      "alg": "HS256"
    }
    ```

2. 生成 payload ：
    ```json
    {
        "username": "leo",
        "exp": 1577853296
    }
    ```

3. 生成 signature ：
    ```js
    var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);
    var signature = HMACSHA256(encodedString, 'secret');  // secret 用于加盐，需要保密
    ```

4. 将上述 header、payload、signature 三部分依次拼接，用点号 . 分隔，就生成了 token ：
    ```js
    var token = base64UrlEncode(header) + '.' + base64UrlEncode(payload) + '.' + signature
    ```

5. 将 token 放到 HTTP Header 中使用：
    ```
    'Authorization': 'Bearer ' + token
    ```

## 单点登录

：SSO（Single Sign On），指多个网站共用一个身份认证系统，使得用户只需登录一次，然后通过同一个身份凭证访问不同网站。
- 优点：
  - 节约了用户登录多个网站的时间。
- 缺点：
  - 增加了单点故障的风险。SSO 系统故障时，多个网站都会不支持用户登录。
- 实现 SSO 的常见协议：
  - OAuth
  - OpenID
  - SAML（安全断言标记语言）：一个认证协议，通信内容采用 XML 格式。
  - CAS（中央验证服务，Central Authentication Service）
  - LDAP
  - Kerberos

### OAuth

：一个实现 SSO 的协议。
- 允许用户通过平台 A 的账号登录第三方应用，也允许第三方应用获取用户在平台 A 上的某些资源。
- 常用的版本是 v2.0 ，它不兼容 v1.0 。

#### 角色划分

- 用户：要通过平台 A 的身份认证登录 app 。
- 第三方应用：简称为 app 。
- 资源服务器：存储着用户在平台 A 上的资源。
- 授权服务器：完成身份认证之后，返回一个 token（访问令牌）给 app ，允许 app 拿着这个 token 发出 HTTP 请求到资源服务器，获取用户在平台 A 上的某些资源。
  - 平台 A 的资源服务器、授权服务器可能是同一台服务器。

#### 工作模式

- 授权码模式
  - ：app 先向授权服务器申请 code（授权码），拼接出申请 token 的登录 URL 。
  - 由平台 A 完成统一的身份认证，避免了用户在每个网站上创建账号的麻烦。
  - 由平台 A 负责实际的身份认证，第三方应用不会知道用户的真实密码，因此这种模式最安全。
- 简化模式
  - ：app 直接向授权服务器申请 token 。当用户从授权服务器跳转回来时，token 会被放在 URL 中，容易泄露。
  - 适用于 app 只有网页，没有后端服务器的情况，比如手机应用。
- 密码模式
  - ：用户将自己的账号密码告诉 app ，让 app 拿着账号密码去获取 token 。这样 app 有权访问用户的所有资源。
- 客户端模式
  - ：授权服务器收到 app 的请求时直接返回 token ，不需要身份认证。

#### 示例

授权码模式的工作流程示例：
1. 用户在 app 的网页上点击 “以其它方式登录” 的链接。
2. app 构造出平台 A 的 OAuth 登录 URL ，让用户 302 重定向到它（采用 GET 请求）。
    - app 要在登录 URL 的请求字符串中加入以下参数：
      ```sh
      client_id       # app 在平台 A 上注册的 id
      redirect_uri    # app 的回调 URL
      response_type   # 表示希望服务器返回的值类型。必须设置为  "code"
      scope           # 表示 app 请求授权的范围
      state           # 一个针对该请求的随机数，用于防止 CSRF 攻击。
      ```
    - 例如：`…….com/oauth/authorize?client_id=……&redirect_uri=……&response_type=code`
    - app 需要事先平台 A 上注册，设置自己的 redirect_uri ，被分配 client_id、client_secret 。
3. 用户在平台 A 的页面上，同意授权给 app 。
    - 平台 A 要验证用户的身份（可能要让用户通过账号密码或其它方式完成登录），然后验证登录 URL 中是否包含了必须参数、这些参数是否有效，最后循环用户是否同意授权给 app 。
    - 如果授权失败或出错，平台 A 应该在自己的网页上告诉用户。
4. 平台 A 构造出 app 的 redirect_uri ，让用户 302 重定向到它（采用 GET 请求）。
    - 平台 A 要在 redirect_uri 的请求字符串中加入以下参数：
      ```sh
      code            # 一个根据 client_id 和 redirect_uri 生成的随机值
      state           # 原样返回 app 的 state
      ```
    - code 应该在几分钟之内过期，减少泄漏的风险。
    - code 是一次性的，如果有 app 拿着用过的 code 来请求平台 A 发放 token ，平台 A 应该拒绝该请求，并撤销基于该 code 发放的 token 。
    - app 应该检查该 state 参数是否与自己发送的相同（可以事先保存在用户的 session 中）。
5. 当用户重定向回到 app 时，app 从 redirect_uri 中解析出 code ，向平台 A 请求 token 。
    - app 的后端服务器发出 POST 报文到平台 A ，请求获取 token 。报文 body 中应该采用 application/x-www-form-urlencoded 格式，包含以下参数：
      ```sh
      client_id
      client_secret
      redirect_uri
      code            # 填入 app 从 redirect_uri 中解析出的 code
      grant_type      # 表示授权模式。必须设置为 "authorization_code"
      ```
    - 平台 A 的响应报文 body 中包含以下参数：
      ```sh
      access_token    # 访问令牌
      expires_in      # token 的过期时间
      refresh_token   # 当 access_token 过期之后，用 refresh_token 来请求新的 access_token
      token_type      # token 的类型，通常为 “bearer”
      scope           # token 的授权范围
      ```
    - 如果 refresh_token 也过期了，就需要用户重新授权。
    - 有的平台只有 access_token ，没有 refresh_token 。
6. app 收到 token ，拿着它向平台 A 请求用户的身份信息（比如用户名）。
    - app 拥有 token 之后，就有权限调用平台 A 的一些 API 了。
7. app 同意用户登录，将用户重定向到自己的业务页面。

### OpenID

：一个实现 SSO 的协议，与 OAuth 类似。
- OpenID 偏向于让第三方应用验证用户在平台 A 上的身份，而 OAuth 偏向于让第三方应用获得用户在平台 A 上的部分权限。

### Kerberos

：一个实现 SSO 的协议。
- 1980 年代由麻省理工学院发布。
- 默认使用 UDP 88 端口。
- 原理：
  - 由身份认证服务器（Authentication Server ，AS）存储所有用户的密钥，负责身份认证。
  - 由票据授权服务器（Ticket Granting Service ，TGS）进行授权。
- 缺点：
  - 身份认证服务器、票据授权服务器存在单点故障的风险。
  - 采用对称加密，加密、解密时使用相同的密钥，因此存在一定风险。


## 多因素身份认证

：MFA（Multi-Factor Authentication）。指同时使用多种方式来验证用户的身份。
- 例如：
  - 当用户通过账号密码验证之后，再验证手机验证码，或者硬件令牌、指纹。
  - 当用户使用 ATM 时，需要同时验证银行卡、密码。
